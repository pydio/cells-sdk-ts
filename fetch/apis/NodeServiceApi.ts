/* tslint:disable */
/* eslint-disable */
/**
 * Pydio Cells Rest API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  IdmSearchUserMetaRequest,
  JobsCtrlCommand,
  RestActionParameters,
  RestBackgroundAction,
  RestBatchUpdateMetaList,
  RestCreateRequest,
  RestError,
  RestListTemplatesResponse,
  RestLookupRequest,
  RestNamespaceValuesOperation,
  RestNamespaceValuesResponse,
  RestNode,
  RestNodeCollection,
  RestNodeUpdates,
  RestPerformActionResponse,
  RestPublicLinkDeleteSuccess,
  RestPublicLinkRequest,
  RestSelection,
  RestShareLink,
  RestUserMetaList,
  RestUserMetaNamespaceCollection,
} from '../models/index';
import {
    IdmSearchUserMetaRequestFromJSON,
    IdmSearchUserMetaRequestToJSON,
    JobsCtrlCommandFromJSON,
    JobsCtrlCommandToJSON,
    RestActionParametersFromJSON,
    RestActionParametersToJSON,
    RestBackgroundActionFromJSON,
    RestBackgroundActionToJSON,
    RestBatchUpdateMetaListFromJSON,
    RestBatchUpdateMetaListToJSON,
    RestCreateRequestFromJSON,
    RestCreateRequestToJSON,
    RestErrorFromJSON,
    RestErrorToJSON,
    RestListTemplatesResponseFromJSON,
    RestListTemplatesResponseToJSON,
    RestLookupRequestFromJSON,
    RestLookupRequestToJSON,
    RestNamespaceValuesOperationFromJSON,
    RestNamespaceValuesOperationToJSON,
    RestNamespaceValuesResponseFromJSON,
    RestNamespaceValuesResponseToJSON,
    RestNodeFromJSON,
    RestNodeToJSON,
    RestNodeCollectionFromJSON,
    RestNodeCollectionToJSON,
    RestNodeUpdatesFromJSON,
    RestNodeUpdatesToJSON,
    RestPerformActionResponseFromJSON,
    RestPerformActionResponseToJSON,
    RestPublicLinkDeleteSuccessFromJSON,
    RestPublicLinkDeleteSuccessToJSON,
    RestPublicLinkRequestFromJSON,
    RestPublicLinkRequestToJSON,
    RestSelectionFromJSON,
    RestSelectionToJSON,
    RestShareLinkFromJSON,
    RestShareLinkToJSON,
    RestUserMetaListFromJSON,
    RestUserMetaListToJSON,
    RestUserMetaNamespaceCollectionFromJSON,
    RestUserMetaNamespaceCollectionToJSON,
} from '../models/index';

export interface BackgroundActionInfoRequest {
    name: BackgroundActionInfoNameEnum;
    jobUuid: string;
}

export interface BatchUpdateMetaRequest {
    body: RestBatchUpdateMetaList;
}

export interface ControlBackgroundActionRequest {
    name: ControlBackgroundActionNameEnum;
    jobUuid: string;
    command: JobsCtrlCommand;
}

export interface CreateRequest {
    body: RestCreateRequest;
}

export interface CreatePublicLinkRequest {
    uuid: string;
    publicLinkRequest: RestPublicLinkRequest;
}

export interface CreateSelectionRequest {
    body: Omit<RestSelection, 'Uuid'>;
}

export interface DeletePublicLinkRequest {
    linkUuid: string;
}

export interface GetByUuidRequest {
    uuid: string;
    path?: string;
}

export interface GetPublicLinkRequest {
    linkUuid: string;
}

export interface ListNamespaceValuesRequest {
    namespace: string;
    operationOperation: ListNamespaceValuesOperationOperationEnum;
    operationValues: Array<string>;
}

export interface ListVersionsRequest {
    uuid: string;
    path?: string;
}

export interface LookupRequest {
    body: RestLookupRequest;
}

export interface PatchNodeRequest {
    uuid: string;
    nodeUpdates: RestNodeUpdates;
}

export interface PerformActionRequest {
    name: PerformActionNameEnum;
    parameters: RestActionParameters;
    jobUuid?: string;
}

export interface SearchMetaRequest {
    body: IdmSearchUserMetaRequest;
}

export interface TemplatesRequest {
    templateType?: string;
}

export interface UpdateNamespaceValuesRequest {
    namespace: string;
    operation: RestNamespaceValuesOperation;
}

export interface UpdatePublicLinkRequest {
    linkUuid: string;
    publicLinkRequest: RestPublicLinkRequest;
}

export interface UserBookmarksRequest {
    all?: boolean;
}

/**
 * 
 */
export class NodeServiceApi extends runtime.BaseAPI {

    /**
     * Retrieve information about an action running in background
     */
    async backgroundActionInfoRaw(requestParameters: BackgroundActionInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBackgroundAction>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling backgroundActionInfo().'
            );
        }

        if (requestParameters['jobUuid'] == null) {
            throw new runtime.RequiredError(
                'jobUuid',
                'Required parameter "jobUuid" was null or undefined when calling backgroundActionInfo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/action/{Name}/{JobUuid}`.replace(`{${"Name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"JobUuid"}}`, encodeURIComponent(String(requestParameters['jobUuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestBackgroundActionFromJSON(jsonValue));
    }

    /**
     * Retrieve information about an action running in background
     */
    async backgroundActionInfo(requestParameters: BackgroundActionInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBackgroundAction> {
        const response = await this.backgroundActionInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
     */
    async batchUpdateMetaRaw(requestParameters: BatchUpdateMetaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBatchUpdateMetaList>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling batchUpdateMeta().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/meta/batch`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: RestBatchUpdateMetaListToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestBatchUpdateMetaListFromJSON(jsonValue));
    }

    /**
     * Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
     */
    async batchUpdateMeta(requestParameters: BatchUpdateMetaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBatchUpdateMetaList> {
        const response = await this.batchUpdateMetaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Send control commands to a background job
     */
    async controlBackgroundActionRaw(requestParameters: ControlBackgroundActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBackgroundAction>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling controlBackgroundAction().'
            );
        }

        if (requestParameters['jobUuid'] == null) {
            throw new runtime.RequiredError(
                'jobUuid',
                'Required parameter "jobUuid" was null or undefined when calling controlBackgroundAction().'
            );
        }

        if (requestParameters['command'] == null) {
            throw new runtime.RequiredError(
                'command',
                'Required parameter "command" was null or undefined when calling controlBackgroundAction().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/action/{Name}/{JobUuid}`.replace(`{${"Name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"JobUuid"}}`, encodeURIComponent(String(requestParameters['jobUuid']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: JobsCtrlCommandToJSON(requestParameters['command']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestBackgroundActionFromJSON(jsonValue));
    }

    /**
     * Send control commands to a background job
     */
    async controlBackgroundAction(requestParameters: ControlBackgroundActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBackgroundAction> {
        const response = await this.controlBackgroundActionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create one or many files (empty or hydrated from a TemplateUuid) or folders
     */
    async createRaw(requestParameters: CreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestNodeCollection>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling create().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/nodes/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RestCreateRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestNodeCollectionFromJSON(jsonValue));
    }

    /**
     * Create one or many files (empty or hydrated from a TemplateUuid) or folders
     */
    async create(requestParameters: CreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestNodeCollection> {
        const response = await this.createRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a public link on a given node
     */
    async createPublicLinkRaw(requestParameters: CreatePublicLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestShareLink>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling createPublicLink().'
            );
        }

        if (requestParameters['publicLinkRequest'] == null) {
            throw new runtime.RequiredError(
                'publicLinkRequest',
                'Required parameter "publicLinkRequest" was null or undefined when calling createPublicLink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/node/{Uuid}/link`.replace(`{${"Uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RestPublicLinkRequestToJSON(requestParameters['publicLinkRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestShareLinkFromJSON(jsonValue));
    }

    /**
     * Create a public link on a given node
     */
    async createPublicLink(requestParameters: CreatePublicLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestShareLink> {
        const response = await this.createPublicLinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create and persist a temporary selection of nodes, that can be used by other actions
     */
    async createSelectionRaw(requestParameters: CreateSelectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSelection>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createSelection().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/selection`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RestSelectionToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestSelectionFromJSON(jsonValue));
    }

    /**
     * Create and persist a temporary selection of nodes, that can be used by other actions
     */
    async createSelection(requestParameters: CreateSelectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSelection> {
        const response = await this.createSelectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a public link
     */
    async deletePublicLinkRaw(requestParameters: DeletePublicLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPublicLinkDeleteSuccess>> {
        if (requestParameters['linkUuid'] == null) {
            throw new runtime.RequiredError(
                'linkUuid',
                'Required parameter "linkUuid" was null or undefined when calling deletePublicLink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/link/{LinkUuid}`.replace(`{${"LinkUuid"}}`, encodeURIComponent(String(requestParameters['linkUuid']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestPublicLinkDeleteSuccessFromJSON(jsonValue));
    }

    /**
     * Remove a public link
     */
    async deletePublicLink(requestParameters: DeletePublicLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPublicLinkDeleteSuccess> {
        const response = await this.deletePublicLinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Load a node by its Uuid
     */
    async getByUuidRaw(requestParameters: GetByUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestNode>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling getByUuid().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['Path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/node/{Uuid}`.replace(`{${"Uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestNodeFromJSON(jsonValue));
    }

    /**
     * Load a node by its Uuid
     */
    async getByUuid(requestParameters: GetByUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestNode> {
        const response = await this.getByUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Load public link information by Uuid
     */
    async getPublicLinkRaw(requestParameters: GetPublicLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestShareLink>> {
        if (requestParameters['linkUuid'] == null) {
            throw new runtime.RequiredError(
                'linkUuid',
                'Required parameter "linkUuid" was null or undefined when calling getPublicLink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/link/{LinkUuid}`.replace(`{${"LinkUuid"}}`, encodeURIComponent(String(requestParameters['linkUuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestShareLinkFromJSON(jsonValue));
    }

    /**
     * Load public link information by Uuid
     */
    async getPublicLink(requestParameters: GetPublicLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestShareLink> {
        const response = await this.getPublicLinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List values for a given namespace
     */
    async listNamespaceValuesRaw(requestParameters: ListNamespaceValuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestNamespaceValuesResponse>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespaceValues().'
            );
        }

        if (requestParameters['operationOperation'] == null) {
            throw new runtime.RequiredError(
                'operationOperation',
                'Required parameter "operationOperation" was null or undefined when calling listNamespaceValues().'
            );
        }

        if (requestParameters['operationValues'] == null) {
            throw new runtime.RequiredError(
                'operationValues',
                'Required parameter "operationValues" was null or undefined when calling listNamespaceValues().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['operationOperation'] != null) {
            queryParameters['Operation.Operation'] = requestParameters['operationOperation'];
        }

        if (requestParameters['operationValues'] != null) {
            queryParameters['Operation.Values'] = requestParameters['operationValues'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/meta/namespace/{Namespace}`.replace(`{${"Namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestNamespaceValuesResponseFromJSON(jsonValue));
    }

    /**
     * List values for a given namespace
     */
    async listNamespaceValues(requestParameters: ListNamespaceValuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestNamespaceValuesResponse> {
        const response = await this.listNamespaceValuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List defined meta namespaces
     */
    async listNamespacesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUserMetaNamespaceCollection>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/meta/namespace`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestUserMetaNamespaceCollectionFromJSON(jsonValue));
    }

    /**
     * List defined meta namespaces
     */
    async listNamespaces(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUserMetaNamespaceCollection> {
        const response = await this.listNamespacesRaw(initOverrides);
        return await response.value();
    }

    /**
     * List all known versions of a node
     */
    async listVersionsRaw(requestParameters: ListVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestNodeCollection>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling listVersions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['Path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/node/{Uuid}/versions`.replace(`{${"Uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestNodeCollectionFromJSON(jsonValue));
    }

    /**
     * List all known versions of a node
     */
    async listVersions(requestParameters: ListVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestNodeCollection> {
        const response = await this.listVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generic request to either list (using Locators) or search (using Query) for nodes
     */
    async lookupRaw(requestParameters: LookupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestNodeCollection>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling lookup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/nodes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RestLookupRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestNodeCollectionFromJSON(jsonValue));
    }

    /**
     * Generic request to either list (using Locators) or search (using Query) for nodes
     */
    async lookup(requestParameters: LookupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestNodeCollection> {
        const response = await this.lookupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
     */
    async patchNodeRaw(requestParameters: PatchNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestNode>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling patchNode().'
            );
        }

        if (requestParameters['nodeUpdates'] == null) {
            throw new runtime.RequiredError(
                'nodeUpdates',
                'Required parameter "nodeUpdates" was null or undefined when calling patchNode().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/node/{Uuid}`.replace(`{${"Uuid"}}`, encodeURIComponent(String(requestParameters['uuid']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: RestNodeUpdatesToJSON(requestParameters['nodeUpdates']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestNodeFromJSON(jsonValue));
    }

    /**
     * PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
     */
    async patchNode(requestParameters: PatchNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestNode> {
        const response = await this.patchNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Trigger an action on the tree. Returns a JobInfo describing a background task.
     */
    async performActionRaw(requestParameters: PerformActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPerformActionResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling performAction().'
            );
        }

        if (requestParameters['parameters'] == null) {
            throw new runtime.RequiredError(
                'parameters',
                'Required parameter "parameters" was null or undefined when calling performAction().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['jobUuid'] != null) {
            queryParameters['JobUuid'] = requestParameters['jobUuid'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/action/{Name}`.replace(`{${"Name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RestActionParametersToJSON(requestParameters['parameters']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestPerformActionResponseFromJSON(jsonValue));
    }

    /**
     * Trigger an action on the tree. Returns a JobInfo describing a background task.
     */
    async performAction(requestParameters: PerformActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPerformActionResponse> {
        const response = await this.performActionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search a list of meta by node Id or by User id and by namespace
     */
    async searchMetaRaw(requestParameters: SearchMetaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUserMetaList>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling searchMeta().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/meta/find`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IdmSearchUserMetaRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestUserMetaListFromJSON(jsonValue));
    }

    /**
     * Search a list of meta by node Id or by User id and by namespace
     */
    async searchMeta(requestParameters: SearchMetaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUserMetaList> {
        const response = await this.searchMetaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List available templates for hydrating empty files
     */
    async templatesRaw(requestParameters: TemplatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestListTemplatesResponse>> {
        const queryParameters: any = {};

        if (requestParameters['templateType'] != null) {
            queryParameters['TemplateType'] = requestParameters['templateType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/templates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestListTemplatesResponseFromJSON(jsonValue));
    }

    /**
     * List available templates for hydrating empty files
     */
    async templates(requestParameters: TemplatesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestListTemplatesResponse> {
        const response = await this.templatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add/delete a values for a given namespace
     */
    async updateNamespaceValuesRaw(requestParameters: UpdateNamespaceValuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestNamespaceValuesResponse>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling updateNamespaceValues().'
            );
        }

        if (requestParameters['operation'] == null) {
            throw new runtime.RequiredError(
                'operation',
                'Required parameter "operation" was null or undefined when calling updateNamespaceValues().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/meta/namespace/{Namespace}`.replace(`{${"Namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: RestNamespaceValuesOperationToJSON(requestParameters['operation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestNamespaceValuesResponseFromJSON(jsonValue));
    }

    /**
     * Add/delete a values for a given namespace
     */
    async updateNamespaceValues(requestParameters: UpdateNamespaceValuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestNamespaceValuesResponse> {
        const response = await this.updateNamespaceValuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update public link settings
     */
    async updatePublicLinkRaw(requestParameters: UpdatePublicLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestShareLink>> {
        if (requestParameters['linkUuid'] == null) {
            throw new runtime.RequiredError(
                'linkUuid',
                'Required parameter "linkUuid" was null or undefined when calling updatePublicLink().'
            );
        }

        if (requestParameters['publicLinkRequest'] == null) {
            throw new runtime.RequiredError(
                'publicLinkRequest',
                'Required parameter "publicLinkRequest" was null or undefined when calling updatePublicLink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/link/{LinkUuid}`.replace(`{${"LinkUuid"}}`, encodeURIComponent(String(requestParameters['linkUuid']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: RestPublicLinkRequestToJSON(requestParameters['publicLinkRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestShareLinkFromJSON(jsonValue));
    }

    /**
     * Update public link settings
     */
    async updatePublicLink(requestParameters: UpdatePublicLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestShareLink> {
        const response = await this.updatePublicLinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
     */
    async userBookmarksRaw(requestParameters: UserBookmarksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestNodeCollection>> {
        const queryParameters: any = {};

        if (requestParameters['all'] != null) {
            queryParameters['All'] = requestParameters['all'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/n/nodes/bookmarks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RestNodeCollectionFromJSON(jsonValue));
    }

    /**
     * Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
     */
    async userBookmarks(requestParameters: UserBookmarksRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestNodeCollection> {
        const response = await this.userBookmarksRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const BackgroundActionInfoNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
} as const;
export type BackgroundActionInfoNameEnum = typeof BackgroundActionInfoNameEnum[keyof typeof BackgroundActionInfoNameEnum];
/**
 * @export
 */
export const ControlBackgroundActionNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
} as const;
export type ControlBackgroundActionNameEnum = typeof ControlBackgroundActionNameEnum[keyof typeof ControlBackgroundActionNameEnum];
/**
 * @export
 */
export const ListNamespaceValuesOperationOperationEnum = {
    Put: 'PUT',
    Delete: 'DELETE'
} as const;
export type ListNamespaceValuesOperationOperationEnum = typeof ListNamespaceValuesOperationOperationEnum[keyof typeof ListNamespaceValuesOperationOperationEnum];
/**
 * @export
 */
export const PerformActionNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
} as const;
export type PerformActionNameEnum = typeof PerformActionNameEnum[keyof typeof PerformActionNameEnum];
