"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Pydio Cells Rest API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformActionNameEnum = exports.ListNamespaceValuesOperationOperationEnum = exports.ControlBackgroundActionNameEnum = exports.BackgroundActionInfoNameEnum = exports.NodeServiceApi = exports.NodeServiceApiFactory = exports.NodeServiceApiFp = exports.NodeServiceApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * NodeServiceApi - axios parameter creator
 * @export
 */
const NodeServiceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Retrieve information about an action running in background
         * @param {BackgroundActionInfoNameEnum} name
         * @param {string} jobUuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundActionInfo: async (name, jobUuid, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('backgroundActionInfo', 'name', name);
            // verify required parameter 'jobUuid' is not null or undefined
            (0, common_1.assertParamExists)('backgroundActionInfo', 'jobUuid', jobUuid);
            const localVarPath = `/n/action/{Name}/{JobUuid}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"JobUuid"}}`, encodeURIComponent(String(jobUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
         * @param {RestBatchUpdateMetaList} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUpdateMeta: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('batchUpdateMeta', 'body', body);
            const localVarPath = `/n/meta/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Send control commands to a background job
         * @param {ControlBackgroundActionNameEnum} name
         * @param {string} jobUuid
         * @param {JobsCtrlCommand} command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlBackgroundAction: async (name, jobUuid, command, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('controlBackgroundAction', 'name', name);
            // verify required parameter 'jobUuid' is not null or undefined
            (0, common_1.assertParamExists)('controlBackgroundAction', 'jobUuid', jobUuid);
            // verify required parameter 'command' is not null or undefined
            (0, common_1.assertParamExists)('controlBackgroundAction', 'command', command);
            const localVarPath = `/n/action/{Name}/{JobUuid}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"JobUuid"}}`, encodeURIComponent(String(jobUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(command, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
         * @param {RestCreateRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('create', 'body', body);
            const localVarPath = `/n/nodes/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Apply some pre-validation checks on node name before sending an upload
         * @param {RestCreateCheckRequest} body Request for pre-checking nodes before uploading or creating them.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createCheck', 'body', body);
            const localVarPath = `/n/nodes/create/precheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a public link on a given node
         * @param {string} uuid
         * @param {RestPublicLinkRequest} publicLinkRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicLink: async (uuid, publicLinkRequest, options = {}) => {
            // verify required parameter 'uuid' is not null or undefined
            (0, common_1.assertParamExists)('createPublicLink', 'uuid', uuid);
            // verify required parameter 'publicLinkRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPublicLink', 'publicLinkRequest', publicLinkRequest);
            const localVarPath = `/n/node/{Uuid}/link`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(publicLinkRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create and persist a temporary selection of nodes, that can be used by other actions
         * @param {RestSelection} body Request to create a selection from a list of nodes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSelection: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createSelection', 'body', body);
            const localVarPath = `/n/selection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove a public link
         * @param {string} linkUuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicLink: async (linkUuid, options = {}) => {
            // verify required parameter 'linkUuid' is not null or undefined
            (0, common_1.assertParamExists)('deletePublicLink', 'linkUuid', linkUuid);
            const localVarPath = `/n/link/{LinkUuid}`
                .replace(`{${"LinkUuid"}}`, encodeURIComponent(String(linkUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a version by its ID
         * @param {string} uuid
         * @param {string} versionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVersion: async (uuid, versionId, options = {}) => {
            // verify required parameter 'uuid' is not null or undefined
            (0, common_1.assertParamExists)('deleteVersion', 'uuid', uuid);
            // verify required parameter 'versionId' is not null or undefined
            (0, common_1.assertParamExists)('deleteVersion', 'versionId', versionId);
            const localVarPath = `/n/node/{Uuid}/versions/{VersionId}`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"VersionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Load a node by its Uuid
         * @param {string} uuid
         * @param {string} [path]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUuid: async (uuid, path, options = {}) => {
            // verify required parameter 'uuid' is not null or undefined
            (0, common_1.assertParamExists)('getByUuid', 'uuid', uuid);
            const localVarPath = `/n/node/{Uuid}`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Load public link information by Uuid
         * @param {string} linkUuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicLink: async (linkUuid, options = {}) => {
            // verify required parameter 'linkUuid' is not null or undefined
            (0, common_1.assertParamExists)('getPublicLink', 'linkUuid', linkUuid);
            const localVarPath = `/n/link/{LinkUuid}`
                .replace(`{${"LinkUuid"}}`, encodeURIComponent(String(linkUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {ListNamespaceValuesOperationOperationEnum} operationOperation
         * @param {Array<string>} operationValues
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaceValues: async (namespace, operationOperation, operationValues, options = {}) => {
            // verify required parameter 'namespace' is not null or undefined
            (0, common_1.assertParamExists)('listNamespaceValues', 'namespace', namespace);
            // verify required parameter 'operationOperation' is not null or undefined
            (0, common_1.assertParamExists)('listNamespaceValues', 'operationOperation', operationOperation);
            // verify required parameter 'operationValues' is not null or undefined
            (0, common_1.assertParamExists)('listNamespaceValues', 'operationValues', operationValues);
            const localVarPath = `/n/meta/namespace/{Namespace}`
                .replace(`{${"Namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (operationOperation !== undefined) {
                localVarQueryParameter['Operation.Operation'] = operationOperation;
            }
            if (operationValues) {
                localVarQueryParameter['Operation.Values'] = operationValues;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List defined meta namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces: async (options = {}) => {
            const localVarPath = `/n/meta/namespace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Generic request to either list (using Locators) or search (using Query) for nodes
         * @param {RestLookupRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookup: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('lookup', 'body', body);
            const localVarPath = `/n/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List all known versions of a node
         * @param {string} uuid The node Uuid
         * @param {RestNodeVersionsFilter} query Additional parameters for filtering/sorting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeVersions: async (uuid, query, options = {}) => {
            // verify required parameter 'uuid' is not null or undefined
            (0, common_1.assertParamExists)('nodeVersions', 'uuid', uuid);
            // verify required parameter 'query' is not null or undefined
            (0, common_1.assertParamExists)('nodeVersions', 'query', query);
            const localVarPath = `/n/node/{Uuid}/versions`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(query, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
         * @param {string} uuid
         * @param {RestNodeUpdates} nodeUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchNode: async (uuid, nodeUpdates, options = {}) => {
            // verify required parameter 'uuid' is not null or undefined
            (0, common_1.assertParamExists)('patchNode', 'uuid', uuid);
            // verify required parameter 'nodeUpdates' is not null or undefined
            (0, common_1.assertParamExists)('patchNode', 'nodeUpdates', nodeUpdates);
            const localVarPath = `/n/node/{Uuid}`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(nodeUpdates, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
         * @param {PerformActionNameEnum} name
         * @param {RestActionParameters} parameters
         * @param {string} [jobUuid]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performAction: async (name, parameters, jobUuid, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('performAction', 'name', name);
            // verify required parameter 'parameters' is not null or undefined
            (0, common_1.assertParamExists)('performAction', 'parameters', parameters);
            const localVarPath = `/n/action/{Name}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (jobUuid !== undefined) {
                localVarQueryParameter['JobUuid'] = jobUuid;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(parameters, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Promotes a version by ID to be the publicly available content of the node - files only
         * @param {string} uuid
         * @param {string} versionId
         * @param {RestPromoteParameters} parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteVersion: async (uuid, versionId, parameters, options = {}) => {
            // verify required parameter 'uuid' is not null or undefined
            (0, common_1.assertParamExists)('promoteVersion', 'uuid', uuid);
            // verify required parameter 'versionId' is not null or undefined
            (0, common_1.assertParamExists)('promoteVersion', 'versionId', versionId);
            // verify required parameter 'parameters' is not null or undefined
            (0, common_1.assertParamExists)('promoteVersion', 'parameters', parameters);
            const localVarPath = `/n/node/{Uuid}/versions/{VersionId}/promote`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"VersionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(parameters, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Unset draft status of a resource, typically to publish a folder in draft mode
         * @param {string} uuid
         * @param {RestPublishNodeParameters} parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishNode: async (uuid, parameters, options = {}) => {
            // verify required parameter 'uuid' is not null or undefined
            (0, common_1.assertParamExists)('publishNode', 'uuid', uuid);
            // verify required parameter 'parameters' is not null or undefined
            (0, common_1.assertParamExists)('publishNode', 'parameters', parameters);
            const localVarPath = `/n/node/{Uuid}/publish`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(parameters, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Search a list of meta by node Id or by User id and by namespace
         * @param {IdmSearchUserMetaRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMeta: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('searchMeta', 'body', body);
            const localVarPath = `/n/meta/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List available templates for hydrating empty files
         * @param {string} [templateType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templates: async (templateType, options = {}) => {
            const localVarPath = `/n/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (templateType !== undefined) {
                localVarQueryParameter['TemplateType'] = templateType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add/delete a values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {RestNamespaceValuesOperation} operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceValues: async (namespace, operation, options = {}) => {
            // verify required parameter 'namespace' is not null or undefined
            (0, common_1.assertParamExists)('updateNamespaceValues', 'namespace', namespace);
            // verify required parameter 'operation' is not null or undefined
            (0, common_1.assertParamExists)('updateNamespaceValues', 'operation', operation);
            const localVarPath = `/n/meta/namespace/{Namespace}`
                .replace(`{${"Namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(operation, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update public link settings
         * @param {string} linkUuid
         * @param {RestPublicLinkRequest} publicLinkRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicLink: async (linkUuid, publicLinkRequest, options = {}) => {
            // verify required parameter 'linkUuid' is not null or undefined
            (0, common_1.assertParamExists)('updatePublicLink', 'linkUuid', linkUuid);
            // verify required parameter 'publicLinkRequest' is not null or undefined
            (0, common_1.assertParamExists)('updatePublicLink', 'publicLinkRequest', publicLinkRequest);
            const localVarPath = `/n/link/{LinkUuid}`
                .replace(`{${"LinkUuid"}}`, encodeURIComponent(String(linkUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(publicLinkRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
         * @param {boolean} [all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBookmarks: async (all, options = {}) => {
            const localVarPath = `/n/nodes/bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (all !== undefined) {
                localVarQueryParameter['All'] = all;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.NodeServiceApiAxiosParamCreator = NodeServiceApiAxiosParamCreator;
/**
 * NodeServiceApi - functional programming interface
 * @export
 */
const NodeServiceApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.NodeServiceApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve information about an action running in background
         * @param {BackgroundActionInfoNameEnum} name
         * @param {string} jobUuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backgroundActionInfo(name, jobUuid, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.backgroundActionInfo(name, jobUuid, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.backgroundActionInfo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
         * @param {RestBatchUpdateMetaList} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchUpdateMeta(body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchUpdateMeta(body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.batchUpdateMeta']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Send control commands to a background job
         * @param {ControlBackgroundActionNameEnum} name
         * @param {string} jobUuid
         * @param {JobsCtrlCommand} command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async controlBackgroundAction(name, jobUuid, command, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.controlBackgroundAction(name, jobUuid, command, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.controlBackgroundAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
         * @param {RestCreateRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.create']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Apply some pre-validation checks on node name before sending an upload
         * @param {RestCreateCheckRequest} body Request for pre-checking nodes before uploading or creating them.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheck(body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheck(body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.createCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create a public link on a given node
         * @param {string} uuid
         * @param {RestPublicLinkRequest} publicLinkRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicLink(uuid, publicLinkRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicLink(uuid, publicLinkRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.createPublicLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create and persist a temporary selection of nodes, that can be used by other actions
         * @param {RestSelection} body Request to create a selection from a list of nodes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSelection(body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSelection(body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.createSelection']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Remove a public link
         * @param {string} linkUuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicLink(linkUuid, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicLink(linkUuid, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.deletePublicLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete a version by its ID
         * @param {string} uuid
         * @param {string} versionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVersion(uuid, versionId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVersion(uuid, versionId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.deleteVersion']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Load a node by its Uuid
         * @param {string} uuid
         * @param {string} [path]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUuid(uuid, path, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUuid(uuid, path, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.getByUuid']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Load public link information by Uuid
         * @param {string} linkUuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicLink(linkUuid, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicLink(linkUuid, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.getPublicLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {ListNamespaceValuesOperationOperationEnum} operationOperation
         * @param {Array<string>} operationValues
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNamespaceValues(namespace, operationOperation, operationValues, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNamespaceValues(namespace, operationOperation, operationValues, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.listNamespaceValues']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List defined meta namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNamespaces(options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNamespaces(options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.listNamespaces']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Generic request to either list (using Locators) or search (using Query) for nodes
         * @param {RestLookupRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookup(body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookup(body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.lookup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List all known versions of a node
         * @param {string} uuid The node Uuid
         * @param {RestNodeVersionsFilter} query Additional parameters for filtering/sorting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodeVersions(uuid, query, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodeVersions(uuid, query, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.nodeVersions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
         * @param {string} uuid
         * @param {RestNodeUpdates} nodeUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchNode(uuid, nodeUpdates, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNode(uuid, nodeUpdates, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.patchNode']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
         * @param {PerformActionNameEnum} name
         * @param {RestActionParameters} parameters
         * @param {string} [jobUuid]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async performAction(name, parameters, jobUuid, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.performAction(name, parameters, jobUuid, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.performAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Promotes a version by ID to be the publicly available content of the node - files only
         * @param {string} uuid
         * @param {string} versionId
         * @param {RestPromoteParameters} parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoteVersion(uuid, versionId, parameters, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoteVersion(uuid, versionId, parameters, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.promoteVersion']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Unset draft status of a resource, typically to publish a folder in draft mode
         * @param {string} uuid
         * @param {RestPublishNodeParameters} parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishNode(uuid, parameters, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishNode(uuid, parameters, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.publishNode']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Search a list of meta by node Id or by User id and by namespace
         * @param {IdmSearchUserMetaRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMeta(body, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMeta(body, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.searchMeta']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List available templates for hydrating empty files
         * @param {string} [templateType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templates(templateType, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.templates(templateType, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.templates']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Add/delete a values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {RestNamespaceValuesOperation} operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamespaceValues(namespace, operation, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNamespaceValues(namespace, operation, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.updateNamespaceValues']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update public link settings
         * @param {string} linkUuid
         * @param {RestPublicLinkRequest} publicLinkRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicLink(linkUuid, publicLinkRequest, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicLink(linkUuid, publicLinkRequest, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.updatePublicLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
         * @param {boolean} [all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBookmarks(all, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBookmarks(all, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NodeServiceApi.userBookmarks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.NodeServiceApiFp = NodeServiceApiFp;
/**
 * NodeServiceApi - factory interface
 * @export
 */
const NodeServiceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.NodeServiceApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve information about an action running in background
         * @param {BackgroundActionInfoNameEnum} name
         * @param {string} jobUuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundActionInfo(name, jobUuid, options) {
            return localVarFp.backgroundActionInfo(name, jobUuid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
         * @param {RestBatchUpdateMetaList} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUpdateMeta(body, options) {
            return localVarFp.batchUpdateMeta(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Send control commands to a background job
         * @param {ControlBackgroundActionNameEnum} name
         * @param {string} jobUuid
         * @param {JobsCtrlCommand} command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlBackgroundAction(name, jobUuid, command, options) {
            return localVarFp.controlBackgroundAction(name, jobUuid, command, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
         * @param {RestCreateRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(body, options) {
            return localVarFp.create(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Apply some pre-validation checks on node name before sending an upload
         * @param {RestCreateCheckRequest} body Request for pre-checking nodes before uploading or creating them.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck(body, options) {
            return localVarFp.createCheck(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a public link on a given node
         * @param {string} uuid
         * @param {RestPublicLinkRequest} publicLinkRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicLink(uuid, publicLinkRequest, options) {
            return localVarFp.createPublicLink(uuid, publicLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create and persist a temporary selection of nodes, that can be used by other actions
         * @param {RestSelection} body Request to create a selection from a list of nodes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSelection(body, options) {
            return localVarFp.createSelection(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove a public link
         * @param {string} linkUuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicLink(linkUuid, options) {
            return localVarFp.deletePublicLink(linkUuid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a version by its ID
         * @param {string} uuid
         * @param {string} versionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVersion(uuid, versionId, options) {
            return localVarFp.deleteVersion(uuid, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Load a node by its Uuid
         * @param {string} uuid
         * @param {string} [path]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUuid(uuid, path, options) {
            return localVarFp.getByUuid(uuid, path, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Load public link information by Uuid
         * @param {string} linkUuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicLink(linkUuid, options) {
            return localVarFp.getPublicLink(linkUuid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {ListNamespaceValuesOperationOperationEnum} operationOperation
         * @param {Array<string>} operationValues
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaceValues(namespace, operationOperation, operationValues, options) {
            return localVarFp.listNamespaceValues(namespace, operationOperation, operationValues, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List defined meta namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces(options) {
            return localVarFp.listNamespaces(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Generic request to either list (using Locators) or search (using Query) for nodes
         * @param {RestLookupRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookup(body, options) {
            return localVarFp.lookup(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all known versions of a node
         * @param {string} uuid The node Uuid
         * @param {RestNodeVersionsFilter} query Additional parameters for filtering/sorting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeVersions(uuid, query, options) {
            return localVarFp.nodeVersions(uuid, query, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
         * @param {string} uuid
         * @param {RestNodeUpdates} nodeUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchNode(uuid, nodeUpdates, options) {
            return localVarFp.patchNode(uuid, nodeUpdates, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
         * @param {PerformActionNameEnum} name
         * @param {RestActionParameters} parameters
         * @param {string} [jobUuid]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performAction(name, parameters, jobUuid, options) {
            return localVarFp.performAction(name, parameters, jobUuid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Promotes a version by ID to be the publicly available content of the node - files only
         * @param {string} uuid
         * @param {string} versionId
         * @param {RestPromoteParameters} parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteVersion(uuid, versionId, parameters, options) {
            return localVarFp.promoteVersion(uuid, versionId, parameters, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Unset draft status of a resource, typically to publish a folder in draft mode
         * @param {string} uuid
         * @param {RestPublishNodeParameters} parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishNode(uuid, parameters, options) {
            return localVarFp.publishNode(uuid, parameters, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search a list of meta by node Id or by User id and by namespace
         * @param {IdmSearchUserMetaRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMeta(body, options) {
            return localVarFp.searchMeta(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List available templates for hydrating empty files
         * @param {string} [templateType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templates(templateType, options) {
            return localVarFp.templates(templateType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add/delete a values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {RestNamespaceValuesOperation} operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceValues(namespace, operation, options) {
            return localVarFp.updateNamespaceValues(namespace, operation, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update public link settings
         * @param {string} linkUuid
         * @param {RestPublicLinkRequest} publicLinkRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicLink(linkUuid, publicLinkRequest, options) {
            return localVarFp.updatePublicLink(linkUuid, publicLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
         * @param {boolean} [all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBookmarks(all, options) {
            return localVarFp.userBookmarks(all, options).then((request) => request(axios, basePath));
        },
    };
};
exports.NodeServiceApiFactory = NodeServiceApiFactory;
/**
 * NodeServiceApi - object-oriented interface
 * @export
 * @class NodeServiceApi
 * @extends {BaseAPI}
 */
class NodeServiceApi extends base_1.BaseAPI {
    /**
     *
     * @summary Retrieve information about an action running in background
     * @param {BackgroundActionInfoNameEnum} name
     * @param {string} jobUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    backgroundActionInfo(name, jobUuid, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).backgroundActionInfo(name, jobUuid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
     * @param {RestBatchUpdateMetaList} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    batchUpdateMeta(body, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).batchUpdateMeta(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Send control commands to a background job
     * @param {ControlBackgroundActionNameEnum} name
     * @param {string} jobUuid
     * @param {JobsCtrlCommand} command
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    controlBackgroundAction(name, jobUuid, command, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).controlBackgroundAction(name, jobUuid, command, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
     * @param {RestCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    create(body, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).create(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Apply some pre-validation checks on node name before sending an upload
     * @param {RestCreateCheckRequest} body Request for pre-checking nodes before uploading or creating them.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    createCheck(body, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).createCheck(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a public link on a given node
     * @param {string} uuid
     * @param {RestPublicLinkRequest} publicLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    createPublicLink(uuid, publicLinkRequest, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).createPublicLink(uuid, publicLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create and persist a temporary selection of nodes, that can be used by other actions
     * @param {RestSelection} body Request to create a selection from a list of nodes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    createSelection(body, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).createSelection(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove a public link
     * @param {string} linkUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    deletePublicLink(linkUuid, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).deletePublicLink(linkUuid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a version by its ID
     * @param {string} uuid
     * @param {string} versionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    deleteVersion(uuid, versionId, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).deleteVersion(uuid, versionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Load a node by its Uuid
     * @param {string} uuid
     * @param {string} [path]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    getByUuid(uuid, path, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).getByUuid(uuid, path, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Load public link information by Uuid
     * @param {string} linkUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    getPublicLink(linkUuid, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).getPublicLink(linkUuid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List values for a given namespace
     * @param {string} namespace List persisted values for this namespace
     * @param {ListNamespaceValuesOperationOperationEnum} operationOperation
     * @param {Array<string>} operationValues
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    listNamespaceValues(namespace, operationOperation, operationValues, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).listNamespaceValues(namespace, operationOperation, operationValues, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List defined meta namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    listNamespaces(options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).listNamespaces(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Generic request to either list (using Locators) or search (using Query) for nodes
     * @param {RestLookupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    lookup(body, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).lookup(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all known versions of a node
     * @param {string} uuid The node Uuid
     * @param {RestNodeVersionsFilter} query Additional parameters for filtering/sorting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    nodeVersions(uuid, query, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).nodeVersions(uuid, query, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
     * @param {string} uuid
     * @param {RestNodeUpdates} nodeUpdates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    patchNode(uuid, nodeUpdates, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).patchNode(uuid, nodeUpdates, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
     * @param {PerformActionNameEnum} name
     * @param {RestActionParameters} parameters
     * @param {string} [jobUuid]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    performAction(name, parameters, jobUuid, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).performAction(name, parameters, jobUuid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Promotes a version by ID to be the publicly available content of the node - files only
     * @param {string} uuid
     * @param {string} versionId
     * @param {RestPromoteParameters} parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    promoteVersion(uuid, versionId, parameters, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).promoteVersion(uuid, versionId, parameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Unset draft status of a resource, typically to publish a folder in draft mode
     * @param {string} uuid
     * @param {RestPublishNodeParameters} parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    publishNode(uuid, parameters, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).publishNode(uuid, parameters, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search a list of meta by node Id or by User id and by namespace
     * @param {IdmSearchUserMetaRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    searchMeta(body, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).searchMeta(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List available templates for hydrating empty files
     * @param {string} [templateType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    templates(templateType, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).templates(templateType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add/delete a values for a given namespace
     * @param {string} namespace List persisted values for this namespace
     * @param {RestNamespaceValuesOperation} operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    updateNamespaceValues(namespace, operation, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).updateNamespaceValues(namespace, operation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update public link settings
     * @param {string} linkUuid
     * @param {RestPublicLinkRequest} publicLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    updatePublicLink(linkUuid, publicLinkRequest, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).updatePublicLink(linkUuid, publicLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
     * @param {boolean} [all]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    userBookmarks(all, options) {
        return (0, exports.NodeServiceApiFp)(this.configuration).userBookmarks(all, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NodeServiceApi = NodeServiceApi;
/**
 * @export
 */
exports.BackgroundActionInfoNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
};
/**
 * @export
 */
exports.ControlBackgroundActionNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
};
/**
 * @export
 */
exports.ListNamespaceValuesOperationOperationEnum = {
    Put: 'PUT',
    Delete: 'DELETE'
};
/**
 * @export
 */
exports.PerformActionNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
};
