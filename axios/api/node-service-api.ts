/* tslint:disable */
/* eslint-disable */
/**
 * Pydio Cells Rest API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { IdmSearchUserMetaRequest } from '../models';
// @ts-ignore
import type { JobsCtrlCommand } from '../models';
// @ts-ignore
import type { RestActionParameters } from '../models';
// @ts-ignore
import type { RestBackgroundAction } from '../models';
// @ts-ignore
import type { RestBatchUpdateMetaList } from '../models';
// @ts-ignore
import type { RestCreateCheckRequest } from '../models';
// @ts-ignore
import type { RestCreateCheckResponse } from '../models';
// @ts-ignore
import type { RestCreateRequest } from '../models';
// @ts-ignore
import type { RestError } from '../models';
// @ts-ignore
import type { RestListTemplatesResponse } from '../models';
// @ts-ignore
import type { RestLookupRequest } from '../models';
// @ts-ignore
import type { RestNamespaceValuesOperation } from '../models';
// @ts-ignore
import type { RestNamespaceValuesResponse } from '../models';
// @ts-ignore
import type { RestNode } from '../models';
// @ts-ignore
import type { RestNodeCollection } from '../models';
// @ts-ignore
import type { RestNodeUpdates } from '../models';
// @ts-ignore
import type { RestPerformActionResponse } from '../models';
// @ts-ignore
import type { RestPublicLinkDeleteSuccess } from '../models';
// @ts-ignore
import type { RestPublicLinkRequest } from '../models';
// @ts-ignore
import type { RestSelection } from '../models';
// @ts-ignore
import type { RestShareLink } from '../models';
// @ts-ignore
import type { RestUserMetaList } from '../models';
// @ts-ignore
import type { RestUserMetaNamespaceCollection } from '../models';
/**
 * NodeServiceApi - axios parameter creator
 * @export
 */
export const NodeServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve information about an action running in background
         * @param {BackgroundActionInfoNameEnum} name 
         * @param {string} jobUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundActionInfo: async (name: BackgroundActionInfoNameEnum, jobUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('backgroundActionInfo', 'name', name)
            // verify required parameter 'jobUuid' is not null or undefined
            assertParamExists('backgroundActionInfo', 'jobUuid', jobUuid)
            const localVarPath = `/n/action/{Name}/{JobUuid}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"JobUuid"}}`, encodeURIComponent(String(jobUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
         * @param {RestBatchUpdateMetaList} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUpdateMeta: async (body: RestBatchUpdateMetaList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('batchUpdateMeta', 'body', body)
            const localVarPath = `/n/meta/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send control commands to a background job
         * @param {ControlBackgroundActionNameEnum} name 
         * @param {string} jobUuid 
         * @param {JobsCtrlCommand} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlBackgroundAction: async (name: ControlBackgroundActionNameEnum, jobUuid: string, command: JobsCtrlCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('controlBackgroundAction', 'name', name)
            // verify required parameter 'jobUuid' is not null or undefined
            assertParamExists('controlBackgroundAction', 'jobUuid', jobUuid)
            // verify required parameter 'command' is not null or undefined
            assertParamExists('controlBackgroundAction', 'command', command)
            const localVarPath = `/n/action/{Name}/{JobUuid}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"JobUuid"}}`, encodeURIComponent(String(jobUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(command, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
         * @param {RestCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (body: RestCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('create', 'body', body)
            const localVarPath = `/n/nodes/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply some pre-validation checks on node name before sending an upload
         * @param {RestCreateCheckRequest} body Request for pre-checking nodes before uploading or creating them.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck: async (body: RestCreateCheckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createCheck', 'body', body)
            const localVarPath = `/n/nodes/create/precheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a public link on a given node
         * @param {string} uuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicLink: async (uuid: string, publicLinkRequest: RestPublicLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('createPublicLink', 'uuid', uuid)
            // verify required parameter 'publicLinkRequest' is not null or undefined
            assertParamExists('createPublicLink', 'publicLinkRequest', publicLinkRequest)
            const localVarPath = `/n/node/{Uuid}/link`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create and persist a temporary selection of nodes, that can be used by other actions
         * @param {RestSelection} body Request to create a selection from a list of nodes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSelection: async (body: RestSelection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createSelection', 'body', body)
            const localVarPath = `/n/selection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a public link
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicLink: async (linkUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkUuid' is not null or undefined
            assertParamExists('deletePublicLink', 'linkUuid', linkUuid)
            const localVarPath = `/n/link/{LinkUuid}`
                .replace(`{${"LinkUuid"}}`, encodeURIComponent(String(linkUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load a node by its Uuid
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUuid: async (uuid: string, path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getByUuid', 'uuid', uuid)
            const localVarPath = `/n/node/{Uuid}`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load public link information by Uuid
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicLink: async (linkUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkUuid' is not null or undefined
            assertParamExists('getPublicLink', 'linkUuid', linkUuid)
            const localVarPath = `/n/link/{LinkUuid}`
                .replace(`{${"LinkUuid"}}`, encodeURIComponent(String(linkUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {ListNamespaceValuesOperationOperationEnum} operationOperation 
         * @param {Array<string>} operationValues 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaceValues: async (namespace: string, operationOperation: ListNamespaceValuesOperationOperationEnum, operationValues: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listNamespaceValues', 'namespace', namespace)
            // verify required parameter 'operationOperation' is not null or undefined
            assertParamExists('listNamespaceValues', 'operationOperation', operationOperation)
            // verify required parameter 'operationValues' is not null or undefined
            assertParamExists('listNamespaceValues', 'operationValues', operationValues)
            const localVarPath = `/n/meta/namespace/{Namespace}`
                .replace(`{${"Namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (operationOperation !== undefined) {
                localVarQueryParameter['Operation.Operation'] = operationOperation;
            }

            if (operationValues) {
                localVarQueryParameter['Operation.Values'] = operationValues;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List defined meta namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/n/meta/namespace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all known versions of a node
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions: async (uuid: string, path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('listVersions', 'uuid', uuid)
            const localVarPath = `/n/node/{Uuid}/versions`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generic request to either list (using Locators) or search (using Query) for nodes
         * @param {RestLookupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookup: async (body: RestLookupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('lookup', 'body', body)
            const localVarPath = `/n/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
         * @param {string} uuid 
         * @param {RestNodeUpdates} nodeUpdates 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchNode: async (uuid: string, nodeUpdates: RestNodeUpdates, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('patchNode', 'uuid', uuid)
            // verify required parameter 'nodeUpdates' is not null or undefined
            assertParamExists('patchNode', 'nodeUpdates', nodeUpdates)
            const localVarPath = `/n/node/{Uuid}`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeUpdates, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
         * @param {PerformActionNameEnum} name 
         * @param {RestActionParameters} parameters 
         * @param {string} [jobUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performAction: async (name: PerformActionNameEnum, parameters: RestActionParameters, jobUuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('performAction', 'name', name)
            // verify required parameter 'parameters' is not null or undefined
            assertParamExists('performAction', 'parameters', parameters)
            const localVarPath = `/n/action/{Name}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (jobUuid !== undefined) {
                localVarQueryParameter['JobUuid'] = jobUuid;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search a list of meta by node Id or by User id and by namespace
         * @param {IdmSearchUserMetaRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMeta: async (body: IdmSearchUserMetaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('searchMeta', 'body', body)
            const localVarPath = `/n/meta/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available templates for hydrating empty files
         * @param {string} [templateType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templates: async (templateType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/n/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (templateType !== undefined) {
                localVarQueryParameter['TemplateType'] = templateType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add/delete a values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {RestNamespaceValuesOperation} operation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceValues: async (namespace: string, operation: RestNamespaceValuesOperation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateNamespaceValues', 'namespace', namespace)
            // verify required parameter 'operation' is not null or undefined
            assertParamExists('updateNamespaceValues', 'operation', operation)
            const localVarPath = `/n/meta/namespace/{Namespace}`
                .replace(`{${"Namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update public link settings
         * @param {string} linkUuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicLink: async (linkUuid: string, publicLinkRequest: RestPublicLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkUuid' is not null or undefined
            assertParamExists('updatePublicLink', 'linkUuid', linkUuid)
            // verify required parameter 'publicLinkRequest' is not null or undefined
            assertParamExists('updatePublicLink', 'publicLinkRequest', publicLinkRequest)
            const localVarPath = `/n/link/{LinkUuid}`
                .replace(`{${"LinkUuid"}}`, encodeURIComponent(String(linkUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
         * @param {boolean} [all] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBookmarks: async (all?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/n/nodes/bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (all !== undefined) {
                localVarQueryParameter['All'] = all;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeServiceApi - functional programming interface
 * @export
 */
export const NodeServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodeServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve information about an action running in background
         * @param {BackgroundActionInfoNameEnum} name 
         * @param {string} jobUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backgroundActionInfo(name: BackgroundActionInfoNameEnum, jobUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestBackgroundAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backgroundActionInfo(name, jobUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.backgroundActionInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
         * @param {RestBatchUpdateMetaList} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchUpdateMeta(body: RestBatchUpdateMetaList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestBatchUpdateMetaList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchUpdateMeta(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.batchUpdateMeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send control commands to a background job
         * @param {ControlBackgroundActionNameEnum} name 
         * @param {string} jobUuid 
         * @param {JobsCtrlCommand} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async controlBackgroundAction(name: ControlBackgroundActionNameEnum, jobUuid: string, command: JobsCtrlCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestBackgroundAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.controlBackgroundAction(name, jobUuid, command, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.controlBackgroundAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
         * @param {RestCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(body: RestCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNodeCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Apply some pre-validation checks on node name before sending an upload
         * @param {RestCreateCheckRequest} body Request for pre-checking nodes before uploading or creating them.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheck(body: RestCreateCheckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestCreateCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheck(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.createCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a public link on a given node
         * @param {string} uuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicLink(uuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestShareLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicLink(uuid, publicLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.createPublicLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create and persist a temporary selection of nodes, that can be used by other actions
         * @param {RestSelection} body Request to create a selection from a list of nodes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSelection(body: RestSelection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestSelection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSelection(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.createSelection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a public link
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicLink(linkUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestPublicLinkDeleteSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicLink(linkUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.deletePublicLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Load a node by its Uuid
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUuid(uuid: string, path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUuid(uuid, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.getByUuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Load public link information by Uuid
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicLink(linkUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestShareLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicLink(linkUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.getPublicLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {ListNamespaceValuesOperationOperationEnum} operationOperation 
         * @param {Array<string>} operationValues 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNamespaceValues(namespace: string, operationOperation: ListNamespaceValuesOperationOperationEnum, operationValues: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNamespaceValuesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNamespaceValues(namespace, operationOperation, operationValues, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.listNamespaceValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List defined meta namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNamespaces(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestUserMetaNamespaceCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNamespaces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.listNamespaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all known versions of a node
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVersions(uuid: string, path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNodeCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVersions(uuid, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.listVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generic request to either list (using Locators) or search (using Query) for nodes
         * @param {RestLookupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookup(body: RestLookupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNodeCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookup(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.lookup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
         * @param {string} uuid 
         * @param {RestNodeUpdates} nodeUpdates 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchNode(uuid: string, nodeUpdates: RestNodeUpdates, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNode(uuid, nodeUpdates, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.patchNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
         * @param {PerformActionNameEnum} name 
         * @param {RestActionParameters} parameters 
         * @param {string} [jobUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async performAction(name: PerformActionNameEnum, parameters: RestActionParameters, jobUuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestPerformActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.performAction(name, parameters, jobUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.performAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search a list of meta by node Id or by User id and by namespace
         * @param {IdmSearchUserMetaRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMeta(body: IdmSearchUserMetaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestUserMetaList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMeta(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.searchMeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List available templates for hydrating empty files
         * @param {string} [templateType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templates(templateType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestListTemplatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templates(templateType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.templates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add/delete a values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {RestNamespaceValuesOperation} operation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamespaceValues(namespace: string, operation: RestNamespaceValuesOperation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNamespaceValuesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNamespaceValues(namespace, operation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.updateNamespaceValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update public link settings
         * @param {string} linkUuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicLink(linkUuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestShareLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicLink(linkUuid, publicLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.updatePublicLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
         * @param {boolean} [all] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBookmarks(all?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNodeCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBookmarks(all, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.userBookmarks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NodeServiceApi - factory interface
 * @export
 */
export const NodeServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodeServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve information about an action running in background
         * @param {BackgroundActionInfoNameEnum} name 
         * @param {string} jobUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundActionInfo(name: BackgroundActionInfoNameEnum, jobUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RestBackgroundAction> {
            return localVarFp.backgroundActionInfo(name, jobUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
         * @param {RestBatchUpdateMetaList} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUpdateMeta(body: RestBatchUpdateMetaList, options?: RawAxiosRequestConfig): AxiosPromise<RestBatchUpdateMetaList> {
            return localVarFp.batchUpdateMeta(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send control commands to a background job
         * @param {ControlBackgroundActionNameEnum} name 
         * @param {string} jobUuid 
         * @param {JobsCtrlCommand} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlBackgroundAction(name: ControlBackgroundActionNameEnum, jobUuid: string, command: JobsCtrlCommand, options?: RawAxiosRequestConfig): AxiosPromise<RestBackgroundAction> {
            return localVarFp.controlBackgroundAction(name, jobUuid, command, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
         * @param {RestCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(body: RestCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection> {
            return localVarFp.create(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply some pre-validation checks on node name before sending an upload
         * @param {RestCreateCheckRequest} body Request for pre-checking nodes before uploading or creating them.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck(body: RestCreateCheckRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestCreateCheckResponse> {
            return localVarFp.createCheck(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a public link on a given node
         * @param {string} uuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicLink(uuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestShareLink> {
            return localVarFp.createPublicLink(uuid, publicLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create and persist a temporary selection of nodes, that can be used by other actions
         * @param {RestSelection} body Request to create a selection from a list of nodes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSelection(body: RestSelection, options?: RawAxiosRequestConfig): AxiosPromise<RestSelection> {
            return localVarFp.createSelection(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a public link
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicLink(linkUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RestPublicLinkDeleteSuccess> {
            return localVarFp.deletePublicLink(linkUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load a node by its Uuid
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUuid(uuid: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestNode> {
            return localVarFp.getByUuid(uuid, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load public link information by Uuid
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicLink(linkUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RestShareLink> {
            return localVarFp.getPublicLink(linkUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {ListNamespaceValuesOperationOperationEnum} operationOperation 
         * @param {Array<string>} operationValues 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaceValues(namespace: string, operationOperation: ListNamespaceValuesOperationOperationEnum, operationValues: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<RestNamespaceValuesResponse> {
            return localVarFp.listNamespaceValues(namespace, operationOperation, operationValues, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List defined meta namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces(options?: RawAxiosRequestConfig): AxiosPromise<RestUserMetaNamespaceCollection> {
            return localVarFp.listNamespaces(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all known versions of a node
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions(uuid: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection> {
            return localVarFp.listVersions(uuid, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generic request to either list (using Locators) or search (using Query) for nodes
         * @param {RestLookupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookup(body: RestLookupRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection> {
            return localVarFp.lookup(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
         * @param {string} uuid 
         * @param {RestNodeUpdates} nodeUpdates 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchNode(uuid: string, nodeUpdates: RestNodeUpdates, options?: RawAxiosRequestConfig): AxiosPromise<RestNode> {
            return localVarFp.patchNode(uuid, nodeUpdates, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
         * @param {PerformActionNameEnum} name 
         * @param {RestActionParameters} parameters 
         * @param {string} [jobUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performAction(name: PerformActionNameEnum, parameters: RestActionParameters, jobUuid?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestPerformActionResponse> {
            return localVarFp.performAction(name, parameters, jobUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search a list of meta by node Id or by User id and by namespace
         * @param {IdmSearchUserMetaRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMeta(body: IdmSearchUserMetaRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestUserMetaList> {
            return localVarFp.searchMeta(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List available templates for hydrating empty files
         * @param {string} [templateType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templates(templateType?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestListTemplatesResponse> {
            return localVarFp.templates(templateType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add/delete a values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {RestNamespaceValuesOperation} operation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceValues(namespace: string, operation: RestNamespaceValuesOperation, options?: RawAxiosRequestConfig): AxiosPromise<RestNamespaceValuesResponse> {
            return localVarFp.updateNamespaceValues(namespace, operation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update public link settings
         * @param {string} linkUuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicLink(linkUuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestShareLink> {
            return localVarFp.updatePublicLink(linkUuid, publicLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
         * @param {boolean} [all] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBookmarks(all?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection> {
            return localVarFp.userBookmarks(all, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodeServiceApi - interface
 * @export
 * @interface NodeServiceApi
 */
export interface NodeServiceApiInterface {
    /**
     * 
     * @summary Retrieve information about an action running in background
     * @param {BackgroundActionInfoNameEnum} name 
     * @param {string} jobUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    backgroundActionInfo(name: BackgroundActionInfoNameEnum, jobUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RestBackgroundAction>;

    /**
     * 
     * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
     * @param {RestBatchUpdateMetaList} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    batchUpdateMeta(body: RestBatchUpdateMetaList, options?: RawAxiosRequestConfig): AxiosPromise<RestBatchUpdateMetaList>;

    /**
     * 
     * @summary Send control commands to a background job
     * @param {ControlBackgroundActionNameEnum} name 
     * @param {string} jobUuid 
     * @param {JobsCtrlCommand} command 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    controlBackgroundAction(name: ControlBackgroundActionNameEnum, jobUuid: string, command: JobsCtrlCommand, options?: RawAxiosRequestConfig): AxiosPromise<RestBackgroundAction>;

    /**
     * 
     * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
     * @param {RestCreateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    create(body: RestCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection>;

    /**
     * 
     * @summary Apply some pre-validation checks on node name before sending an upload
     * @param {RestCreateCheckRequest} body Request for pre-checking nodes before uploading or creating them.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    createCheck(body: RestCreateCheckRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestCreateCheckResponse>;

    /**
     * 
     * @summary Create a public link on a given node
     * @param {string} uuid 
     * @param {RestPublicLinkRequest} publicLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    createPublicLink(uuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestShareLink>;

    /**
     * 
     * @summary Create and persist a temporary selection of nodes, that can be used by other actions
     * @param {RestSelection} body Request to create a selection from a list of nodes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    createSelection(body: RestSelection, options?: RawAxiosRequestConfig): AxiosPromise<RestSelection>;

    /**
     * 
     * @summary Remove a public link
     * @param {string} linkUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    deletePublicLink(linkUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RestPublicLinkDeleteSuccess>;

    /**
     * 
     * @summary Load a node by its Uuid
     * @param {string} uuid 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    getByUuid(uuid: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestNode>;

    /**
     * 
     * @summary Load public link information by Uuid
     * @param {string} linkUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    getPublicLink(linkUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RestShareLink>;

    /**
     * 
     * @summary List values for a given namespace
     * @param {string} namespace List persisted values for this namespace
     * @param {ListNamespaceValuesOperationOperationEnum} operationOperation 
     * @param {Array<string>} operationValues 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    listNamespaceValues(namespace: string, operationOperation: ListNamespaceValuesOperationOperationEnum, operationValues: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<RestNamespaceValuesResponse>;

    /**
     * 
     * @summary List defined meta namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    listNamespaces(options?: RawAxiosRequestConfig): AxiosPromise<RestUserMetaNamespaceCollection>;

    /**
     * 
     * @summary List all known versions of a node
     * @param {string} uuid 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    listVersions(uuid: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection>;

    /**
     * 
     * @summary Generic request to either list (using Locators) or search (using Query) for nodes
     * @param {RestLookupRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    lookup(body: RestLookupRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection>;

    /**
     * 
     * @summary PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
     * @param {string} uuid 
     * @param {RestNodeUpdates} nodeUpdates 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    patchNode(uuid: string, nodeUpdates: RestNodeUpdates, options?: RawAxiosRequestConfig): AxiosPromise<RestNode>;

    /**
     * 
     * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
     * @param {PerformActionNameEnum} name 
     * @param {RestActionParameters} parameters 
     * @param {string} [jobUuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    performAction(name: PerformActionNameEnum, parameters: RestActionParameters, jobUuid?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestPerformActionResponse>;

    /**
     * 
     * @summary Search a list of meta by node Id or by User id and by namespace
     * @param {IdmSearchUserMetaRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    searchMeta(body: IdmSearchUserMetaRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestUserMetaList>;

    /**
     * 
     * @summary List available templates for hydrating empty files
     * @param {string} [templateType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    templates(templateType?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestListTemplatesResponse>;

    /**
     * 
     * @summary Add/delete a values for a given namespace
     * @param {string} namespace List persisted values for this namespace
     * @param {RestNamespaceValuesOperation} operation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    updateNamespaceValues(namespace: string, operation: RestNamespaceValuesOperation, options?: RawAxiosRequestConfig): AxiosPromise<RestNamespaceValuesResponse>;

    /**
     * 
     * @summary Update public link settings
     * @param {string} linkUuid 
     * @param {RestPublicLinkRequest} publicLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    updatePublicLink(linkUuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestShareLink>;

    /**
     * 
     * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
     * @param {boolean} [all] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApiInterface
     */
    userBookmarks(all?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection>;

}

/**
 * NodeServiceApi - object-oriented interface
 * @export
 * @class NodeServiceApi
 * @extends {BaseAPI}
 */
export class NodeServiceApi extends BaseAPI implements NodeServiceApiInterface {
    /**
     * 
     * @summary Retrieve information about an action running in background
     * @param {BackgroundActionInfoNameEnum} name 
     * @param {string} jobUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public backgroundActionInfo(name: BackgroundActionInfoNameEnum, jobUuid: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).backgroundActionInfo(name, jobUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
     * @param {RestBatchUpdateMetaList} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public batchUpdateMeta(body: RestBatchUpdateMetaList, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).batchUpdateMeta(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send control commands to a background job
     * @param {ControlBackgroundActionNameEnum} name 
     * @param {string} jobUuid 
     * @param {JobsCtrlCommand} command 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public controlBackgroundAction(name: ControlBackgroundActionNameEnum, jobUuid: string, command: JobsCtrlCommand, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).controlBackgroundAction(name, jobUuid, command, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
     * @param {RestCreateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public create(body: RestCreateRequest, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).create(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply some pre-validation checks on node name before sending an upload
     * @param {RestCreateCheckRequest} body Request for pre-checking nodes before uploading or creating them.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public createCheck(body: RestCreateCheckRequest, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).createCheck(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a public link on a given node
     * @param {string} uuid 
     * @param {RestPublicLinkRequest} publicLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public createPublicLink(uuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).createPublicLink(uuid, publicLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create and persist a temporary selection of nodes, that can be used by other actions
     * @param {RestSelection} body Request to create a selection from a list of nodes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public createSelection(body: RestSelection, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).createSelection(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a public link
     * @param {string} linkUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public deletePublicLink(linkUuid: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).deletePublicLink(linkUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load a node by its Uuid
     * @param {string} uuid 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public getByUuid(uuid: string, path?: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).getByUuid(uuid, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load public link information by Uuid
     * @param {string} linkUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public getPublicLink(linkUuid: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).getPublicLink(linkUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List values for a given namespace
     * @param {string} namespace List persisted values for this namespace
     * @param {ListNamespaceValuesOperationOperationEnum} operationOperation 
     * @param {Array<string>} operationValues 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public listNamespaceValues(namespace: string, operationOperation: ListNamespaceValuesOperationOperationEnum, operationValues: Array<string>, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).listNamespaceValues(namespace, operationOperation, operationValues, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List defined meta namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public listNamespaces(options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).listNamespaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all known versions of a node
     * @param {string} uuid 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public listVersions(uuid: string, path?: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).listVersions(uuid, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generic request to either list (using Locators) or search (using Query) for nodes
     * @param {RestLookupRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public lookup(body: RestLookupRequest, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).lookup(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
     * @param {string} uuid 
     * @param {RestNodeUpdates} nodeUpdates 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public patchNode(uuid: string, nodeUpdates: RestNodeUpdates, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).patchNode(uuid, nodeUpdates, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
     * @param {PerformActionNameEnum} name 
     * @param {RestActionParameters} parameters 
     * @param {string} [jobUuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public performAction(name: PerformActionNameEnum, parameters: RestActionParameters, jobUuid?: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).performAction(name, parameters, jobUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search a list of meta by node Id or by User id and by namespace
     * @param {IdmSearchUserMetaRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public searchMeta(body: IdmSearchUserMetaRequest, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).searchMeta(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List available templates for hydrating empty files
     * @param {string} [templateType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public templates(templateType?: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).templates(templateType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add/delete a values for a given namespace
     * @param {string} namespace List persisted values for this namespace
     * @param {RestNamespaceValuesOperation} operation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public updateNamespaceValues(namespace: string, operation: RestNamespaceValuesOperation, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).updateNamespaceValues(namespace, operation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update public link settings
     * @param {string} linkUuid 
     * @param {RestPublicLinkRequest} publicLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public updatePublicLink(linkUuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).updatePublicLink(linkUuid, publicLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
     * @param {boolean} [all] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public userBookmarks(all?: boolean, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).userBookmarks(all, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BackgroundActionInfoNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
} as const;
export type BackgroundActionInfoNameEnum = typeof BackgroundActionInfoNameEnum[keyof typeof BackgroundActionInfoNameEnum];
/**
 * @export
 */
export const ControlBackgroundActionNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
} as const;
export type ControlBackgroundActionNameEnum = typeof ControlBackgroundActionNameEnum[keyof typeof ControlBackgroundActionNameEnum];
/**
 * @export
 */
export const ListNamespaceValuesOperationOperationEnum = {
    Put: 'PUT',
    Delete: 'DELETE'
} as const;
export type ListNamespaceValuesOperationOperationEnum = typeof ListNamespaceValuesOperationOperationEnum[keyof typeof ListNamespaceValuesOperationOperationEnum];
/**
 * @export
 */
export const PerformActionNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
} as const;
export type PerformActionNameEnum = typeof PerformActionNameEnum[keyof typeof PerformActionNameEnum];
