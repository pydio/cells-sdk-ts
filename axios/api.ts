/* tslint:disable */
/* eslint-disable */
/**
 * Pydio Cells Rest API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActivityObject
 */
export interface ActivityObject {
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    '@context'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActivityObject
     */
    'accuracy'?: number;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'actor'?: ActivityObject;
    /**
     * 
     * @type {number}
     * @memberof ActivityObject
     */
    'altitude'?: number;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'anyOf'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'attachment'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'attributedTo'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'audience'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'bcc'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'bto'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'cc'?: ActivityObject;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'closed'?: string;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'content'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'context'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'current'?: ActivityObject;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'deleted'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'duration'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'endTime'?: string;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'first'?: ActivityObject;
    /**
     * 
     * @type {ActivityObjectType}
     * @memberof ActivityObject
     */
    'formerType'?: ActivityObjectType;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'generator'?: ActivityObject;
    /**
     * 
     * @type {number}
     * @memberof ActivityObject
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'hreflang'?: string;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'icon'?: ActivityObject;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'id'?: string;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'image'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'inReplyTo'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'instrument'?: ActivityObject;
    /**
     * 
     * @type {Array<ActivityObject>}
     * @memberof ActivityObject
     */
    'items'?: Array<ActivityObject>;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'last'?: ActivityObject;
    /**
     * 
     * @type {number}
     * @memberof ActivityObject
     */
    'latitude'?: number;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'location'?: ActivityObject;
    /**
     * 
     * @type {number}
     * @memberof ActivityObject
     */
    'longitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'markdown'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'mediaType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'name'?: string;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'next'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'object'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'oneOf'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'origin'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'partOf'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'prev'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'preview'?: ActivityObject;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'published'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActivityObject
     */
    'radius'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'rel'?: string;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'relationship'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'replies'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'result'?: ActivityObject;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'startTime'?: string;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'subject'?: ActivityObject;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'summary'?: string;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'tag'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'target'?: ActivityObject;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'to'?: ActivityObject;
    /**
     * 
     * @type {number}
     * @memberof ActivityObject
     */
    'totalItems'?: number;
    /**
     * 
     * @type {ActivityObjectType}
     * @memberof ActivityObject
     */
    'type'?: ActivityObjectType;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'units'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityObject
     */
    'updated'?: string;
    /**
     * 
     * @type {ActivityObject}
     * @memberof ActivityObject
     */
    'url'?: ActivityObject;
    /**
     * 
     * @type {number}
     * @memberof ActivityObject
     */
    'width'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ActivityObjectType = {
    BaseObject: 'BaseObject',
    Activity: 'Activity',
    Link: 'Link',
    Mention: 'Mention',
    Collection: 'Collection',
    OrderedCollection: 'OrderedCollection',
    CollectionPage: 'CollectionPage',
    OrderedCollectionPage: 'OrderedCollectionPage',
    Application: 'Application',
    Group: 'Group',
    Organization: 'Organization',
    Person: 'Person',
    Service: 'Service',
    Article: 'Article',
    Audio: 'Audio',
    Document: 'Document',
    Event: 'Event',
    Image: 'Image',
    Note: 'Note',
    Page: 'Page',
    Place: 'Place',
    Profile: 'Profile',
    Relationship: 'Relationship',
    Tombstone: 'Tombstone',
    Video: 'Video',
    Accept: 'Accept',
    Add: 'Add',
    Announce: 'Announce',
    Arrive: 'Arrive',
    Block: 'Block',
    Create: 'Create',
    Delete: 'Delete',
    Dislike: 'Dislike',
    Flag: 'Flag',
    Follow: 'Follow',
    Ignore: 'Ignore',
    Invite: 'Invite',
    Join: 'Join',
    Leave: 'Leave',
    Like: 'Like',
    Listen: 'Listen',
    Move: 'Move',
    Offer: 'Offer',
    Question: 'Question',
    Reject: 'Reject',
    Read: 'Read',
    Remove: 'Remove',
    TentativeReject: 'TentativeReject',
    TentativeAccept: 'TentativeAccept',
    Travel: 'Travel',
    Undo: 'Undo',
    Update: 'Update',
    UpdateComment: 'UpdateComment',
    UpdateMeta: 'UpdateMeta',
    View: 'View',
    Workspace: 'Workspace',
    Digest: 'Digest',
    Folder: 'Folder',
    Cell: 'Cell',
    Share: 'Share'
} as const;

export type ActivityObjectType = typeof ActivityObjectType[keyof typeof ActivityObjectType];


/**
 * 
 * @export
 * @enum {string}
 */

export const ActivityOwnerType = {
    Node: 'NODE',
    User: 'USER'
} as const;

export type ActivityOwnerType = typeof ActivityOwnerType[keyof typeof ActivityOwnerType];


/**
 * 
 * @export
 * @interface ActivitySubscription
 */
export interface ActivitySubscription {
    /**
     * 
     * @type {Array<string>}
     * @memberof ActivitySubscription
     */
    'Events'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ActivitySubscription
     */
    'ObjectId'?: string;
    /**
     * 
     * @type {ActivityOwnerType}
     * @memberof ActivitySubscription
     */
    'ObjectType'?: ActivityOwnerType;
    /**
     * 
     * @type {string}
     * @memberof ActivitySubscription
     */
    'UserId'?: string;
}


/**
 * 
 * @export
 * @interface IdmSearchUserMetaRequest
 */
export interface IdmSearchUserMetaRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof IdmSearchUserMetaRequest
     */
    'MetaUuids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IdmSearchUserMetaRequest
     */
    'Namespace'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdmSearchUserMetaRequest
     */
    'NodeUuids'?: Array<string>;
    /**
     * 
     * @type {ServiceResourcePolicyQuery}
     * @memberof IdmSearchUserMetaRequest
     */
    'ResourceQuery'?: ServiceResourcePolicyQuery;
    /**
     * 
     * @type {string}
     * @memberof IdmSearchUserMetaRequest
     */
    'ResourceSubjectOwner'?: string;
}
/**
 * 
 * @export
 * @interface IdmUserMetaNamespace
 */
export interface IdmUserMetaNamespace {
    /**
     * 
     * @type {boolean}
     * @memberof IdmUserMetaNamespace
     */
    'Indexable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IdmUserMetaNamespace
     */
    'JsonDefinition'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdmUserMetaNamespace
     */
    'Label'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdmUserMetaNamespace
     */
    'Namespace'?: string;
    /**
     * 
     * @type {number}
     * @memberof IdmUserMetaNamespace
     */
    'Order'?: number;
    /**
     * 
     * @type {Array<ServiceResourcePolicy>}
     * @memberof IdmUserMetaNamespace
     */
    'Policies'?: Array<ServiceResourcePolicy>;
    /**
     * 
     * @type {boolean}
     * @memberof IdmUserMetaNamespace
     */
    'PoliciesContextEditable'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IdmWorkspaceScope = {
    Any: 'ANY',
    Admin: 'ADMIN',
    Room: 'ROOM',
    Link: 'LINK'
} as const;

export type IdmWorkspaceScope = typeof IdmWorkspaceScope[keyof typeof IdmWorkspaceScope];


/**
 * 
 * @export
 * @enum {string}
 */

export const JobsCommand = {
    None: 'None',
    Pause: 'Pause',
    Resume: 'Resume',
    Stop: 'Stop',
    Delete: 'Delete',
    RunOnce: 'RunOnce',
    Inactive: 'Inactive',
    Active: 'Active'
} as const;

export type JobsCommand = typeof JobsCommand[keyof typeof JobsCommand];


/**
 * 
 * @export
 * @interface JobsCtrlCommand
 */
export interface JobsCtrlCommand {
    /**
     * 
     * @type {JobsCommand}
     * @memberof JobsCtrlCommand
     */
    'Cmd'?: JobsCommand;
    /**
     * 
     * @type {string}
     * @memberof JobsCtrlCommand
     */
    'JobId'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsCtrlCommand
     */
    'OwnerId'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof JobsCtrlCommand
     */
    'RunParameters'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof JobsCtrlCommand
     */
    'TaskId'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const JobsTaskStatus = {
    Unknown: 'Unknown',
    Idle: 'Idle',
    Running: 'Running',
    Finished: 'Finished',
    Interrupted: 'Interrupted',
    Paused: 'Paused',
    Any: 'Any',
    Error: 'Error',
    Queued: 'Queued'
} as const;

export type JobsTaskStatus = typeof JobsTaskStatus[keyof typeof JobsTaskStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const MetaUpdateOp = {
    Put: 'PUT',
    Delete: 'DELETE'
} as const;

export type MetaUpdateOp = typeof MetaUpdateOp[keyof typeof MetaUpdateOp];


/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }     // or ...     if (any.isSameTypeAs(Foo.getDefaultInstance())) {       foo = any.unpack(Foo.getDefaultInstance());     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".  JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    [key: string]: object | any;

    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface RestActionParameters
 */
export interface RestActionParameters {
    /**
     * 
     * @type {JobsTaskStatus}
     * @memberof RestActionParameters
     */
    'AwaitStatus'?: JobsTaskStatus;
    /**
     * 
     * @type {string}
     * @memberof RestActionParameters
     */
    'AwaitTimeout'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestActionParameters
     */
    'JsonParameters'?: string;
    /**
     * 
     * @type {Array<RestNodeLocator>}
     * @memberof RestActionParameters
     */
    'Nodes'?: Array<RestNodeLocator>;
    /**
     * 
     * @type {string}
     * @memberof RestActionParameters
     */
    'SelectionUuid'?: string;
    /**
     * 
     * @type {RestNodeLocator}
     * @memberof RestActionParameters
     */
    'TargetNode'?: RestNodeLocator;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RestActionStatus = {
    Performed: 'Performed',
    Background: 'Background'
} as const;

export type RestActionStatus = typeof RestActionStatus[keyof typeof RestActionStatus];


/**
 * 
 * @export
 * @interface RestBackgroundAction
 */
export interface RestBackgroundAction {
    /**
     * 
     * @type {boolean}
     * @memberof RestBackgroundAction
     */
    'CanPause'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RestBackgroundAction
     */
    'CanStop'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RestBackgroundAction
     */
    'EndTime'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RestBackgroundAction
     */
    'HasProgress'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestBackgroundAction
     */
    'JobUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestBackgroundAction
     */
    'Label'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestBackgroundAction
     */
    'Name'?: string;
    /**
     * 
     * @type {number}
     * @memberof RestBackgroundAction
     */
    'Progress'?: number;
    /**
     * 
     * @type {number}
     * @memberof RestBackgroundAction
     */
    'StartTime'?: number;
    /**
     * 
     * @type {JobsTaskStatus}
     * @memberof RestBackgroundAction
     */
    'Status'?: JobsTaskStatus;
    /**
     * 
     * @type {string}
     * @memberof RestBackgroundAction
     */
    'StatusMessage'?: string;
}


/**
 * 
 * @export
 * @interface RestBatchUpdateMetaList
 */
export interface RestBatchUpdateMetaList {
    /**
     * 
     * @type {Array<RestMetaUpdate>}
     * @memberof RestBatchUpdateMetaList
     */
    'Updates'?: Array<RestMetaUpdate>;
}
/**
 * 
 * @export
 * @interface RestContextWorkspace
 */
export interface RestContextWorkspace {
    /**
     * 
     * @type {string}
     * @memberof RestContextWorkspace
     */
    'Description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RestContextWorkspace
     */
    'IsRoot'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RestContextWorkspace
     */
    'IsVirtualRoot'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestContextWorkspace
     */
    'Label'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestContextWorkspace
     */
    'Permissions'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestContextWorkspace
     */
    'Quota'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestContextWorkspace
     */
    'QuotaUsage'?: string;
    /**
     * 
     * @type {IdmWorkspaceScope}
     * @memberof RestContextWorkspace
     */
    'Scope'?: IdmWorkspaceScope;
    /**
     * 
     * @type {boolean}
     * @memberof RestContextWorkspace
     */
    'SkipRecycle'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestContextWorkspace
     */
    'Slug'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RestContextWorkspace
     */
    'Syncable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestContextWorkspace
     */
    'Uuid'?: string;
}


/**
 * 
 * @export
 * @interface RestCountMeta
 */
export interface RestCountMeta {
    /**
     * 
     * @type {string}
     * @memberof RestCountMeta
     */
    'Namespace'?: string;
    /**
     * 
     * @type {number}
     * @memberof RestCountMeta
     */
    'Value'?: number;
}
/**
 * 
 * @export
 * @interface RestCreateRequest
 */
export interface RestCreateRequest {
    /**
     * 
     * @type {Array<RestIncomingNode>}
     * @memberof RestCreateRequest
     */
    'Inputs'?: Array<RestIncomingNode>;
    /**
     * 
     * @type {boolean}
     * @memberof RestCreateRequest
     */
    'Recursive'?: boolean;
}
/**
 * 
 * @export
 * @interface RestDataSourceFeatures
 */
export interface RestDataSourceFeatures {
    /**
     * 
     * @type {boolean}
     * @memberof RestDataSourceFeatures
     */
    'Encrypted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RestDataSourceFeatures
     */
    'Versioned'?: boolean;
}
/**
 * 
 * @export
 * @interface RestError
 */
export interface RestError {
    /**
     * 
     * @type {string}
     * @memberof RestError
     */
    'Code'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestError
     */
    'Detail'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RestError
     */
    'Meta'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof RestError
     */
    'Source'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestError
     */
    'Title'?: string;
}
/**
 * 
 * @export
 * @interface RestFilePreview
 */
export interface RestFilePreview {
    /**
     * 
     * @type {string}
     * @memberof RestFilePreview
     */
    'ContentType'?: string;
    /**
     * 
     * @type {number}
     * @memberof RestFilePreview
     */
    'Dimension'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RestFilePreview
     */
    'Processing'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestFilePreview
     */
    'Url'?: string;
}
/**
 * 
 * @export
 * @interface RestImageMeta
 */
export interface RestImageMeta {
    /**
     * 
     * @type {number}
     * @memberof RestImageMeta
     */
    'Height'?: number;
    /**
     * 
     * @type {string}
     * @memberof RestImageMeta
     */
    'JsonEXIF'?: string;
    /**
     * 
     * @type {number}
     * @memberof RestImageMeta
     */
    'Orientation'?: number;
    /**
     * 
     * @type {number}
     * @memberof RestImageMeta
     */
    'Width'?: number;
}
/**
 * 
 * @export
 * @interface RestIncomingNode
 */
export interface RestIncomingNode {
    /**
     * 
     * @type {string}
     * @memberof RestIncomingNode
     */
    'ContentType'?: string;
    /**
     * 
     * @type {RestNodeLocator}
     * @memberof RestIncomingNode
     */
    'Locator'?: RestNodeLocator;
    /**
     * 
     * @type {string}
     * @memberof RestIncomingNode
     */
    'TemplateUuid'?: string;
    /**
     * 
     * @type {TreeNodeType}
     * @memberof RestIncomingNode
     */
    'Type'?: TreeNodeType;
}


/**
 * 
 * @export
 * @interface RestJsonMeta
 */
export interface RestJsonMeta {
    /**
     * 
     * @type {string}
     * @memberof RestJsonMeta
     */
    'Namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestJsonMeta
     */
    'Value'?: string;
}
/**
 * 
 * @export
 * @interface RestListTemplatesResponse
 */
export interface RestListTemplatesResponse {
    /**
     * 
     * @type {Array<RestTemplate>}
     * @memberof RestListTemplatesResponse
     */
    'Templates'?: Array<RestTemplate>;
}
/**
 * 
 * @export
 * @interface RestLockInfo
 */
export interface RestLockInfo {
    /**
     * 
     * @type {boolean}
     * @memberof RestLockInfo
     */
    'IsLocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestLockInfo
     */
    'Owner'?: string;
}
/**
 * 
 * @export
 * @interface RestLookupRequest
 */
export interface RestLookupRequest {
    /**
     * 
     * @type {string}
     * @memberof RestLookupRequest
     */
    'Limit'?: string;
    /**
     * 
     * @type {RestNodeLocators}
     * @memberof RestLookupRequest
     */
    'Locators'?: RestNodeLocators;
    /**
     * 
     * @type {string}
     * @memberof RestLookupRequest
     */
    'Offset'?: string;
    /**
     * 
     * @type {TreeQuery}
     * @memberof RestLookupRequest
     */
    'Query'?: TreeQuery;
    /**
     * 
     * @type {boolean}
     * @memberof RestLookupRequest
     */
    'SortDirDesc'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestLookupRequest
     */
    'SortField'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof RestLookupRequest
     */
    'StatFlags'?: Array<number>;
}
/**
 * 
 * @export
 * @interface RestMetaToggle
 */
export interface RestMetaToggle {
    /**
     * 
     * @type {boolean}
     * @memberof RestMetaToggle
     */
    'Value'?: boolean;
}
/**
 * 
 * @export
 * @interface RestMetaUpdate
 */
export interface RestMetaUpdate {
    /**
     * 
     * @type {MetaUpdateOp}
     * @memberof RestMetaUpdate
     */
    'Operation'?: MetaUpdateOp;
    /**
     * 
     * @type {RestUserMeta}
     * @memberof RestMetaUpdate
     */
    'UserMeta'?: RestUserMeta;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RestMode = {
    Default: 'Default',
    NodeReadOnly: 'NodeReadOnly',
    NodeWriteOnly: 'NodeWriteOnly',
    LevelReadOnly: 'LevelReadOnly'
} as const;

export type RestMode = typeof RestMode[keyof typeof RestMode];


/**
 * 
 * @export
 * @interface RestNamespaceValuesOperation
 */
export interface RestNamespaceValuesOperation {
    /**
     * 
     * @type {RestNsOp}
     * @memberof RestNamespaceValuesOperation
     */
    'Operation'?: RestNsOp;
    /**
     * 
     * @type {Array<string>}
     * @memberof RestNamespaceValuesOperation
     */
    'Values'?: Array<string>;
}


/**
 * 
 * @export
 * @interface RestNamespaceValuesResponse
 */
export interface RestNamespaceValuesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof RestNamespaceValuesResponse
     */
    'Values'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RestNode
 */
export interface RestNode {
    /**
     * 
     * @type {Array<ActivityObject>}
     * @memberof RestNode
     */
    'Activities'?: Array<ActivityObject>;
    /**
     * 
     * @type {RestLockInfo}
     * @memberof RestNode
     */
    'ContentLock'?: RestLockInfo;
    /**
     * 
     * @type {string}
     * @memberof RestNode
     */
    'ContentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestNode
     */
    'ContentsHash'?: string;
    /**
     * 
     * @type {RestContextWorkspace}
     * @memberof RestNode
     */
    'ContextWorkspace'?: RestContextWorkspace;
    /**
     * 
     * @type {RestDataSourceFeatures}
     * @memberof RestNode
     */
    'DataSourceFeatures'?: RestDataSourceFeatures;
    /**
     * 
     * @type {Array<RestCountMeta>}
     * @memberof RestNode
     */
    'FolderMeta'?: Array<RestCountMeta>;
    /**
     * 
     * @type {string}
     * @memberof RestNode
     */
    'HashingMethod'?: string;
    /**
     * 
     * @type {RestImageMeta}
     * @memberof RestNode
     */
    'ImageMeta'?: RestImageMeta;
    /**
     * 
     * @type {boolean}
     * @memberof RestNode
     */
    'IsBookmarked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RestNode
     */
    'IsRecycleBin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RestNode
     */
    'IsRecycled'?: boolean;
    /**
     * 
     * @type {Array<RestJsonMeta>}
     * @memberof RestNode
     */
    'Metadata'?: Array<RestJsonMeta>;
    /**
     * 
     * @type {RestMode}
     * @memberof RestNode
     */
    'Mode'?: RestMode;
    /**
     * 
     * @type {string}
     * @memberof RestNode
     */
    'Modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestNode
     */
    'Path'?: string;
    /**
     * 
     * @type {Array<RestFilePreview>}
     * @memberof RestNode
     */
    'Previews'?: Array<RestFilePreview>;
    /**
     * 
     * @type {RestRevisionMeta}
     * @memberof RestNode
     */
    'RevisionMeta'?: RestRevisionMeta;
    /**
     * 
     * @type {Array<RestShareLink>}
     * @memberof RestNode
     */
    'Shares'?: Array<RestShareLink>;
    /**
     * 
     * @type {string}
     * @memberof RestNode
     */
    'Size'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestNode
     */
    'StorageETag'?: string;
    /**
     * 
     * @type {Array<ActivitySubscription>}
     * @memberof RestNode
     */
    'Subscriptions'?: Array<ActivitySubscription>;
    /**
     * 
     * @type {TreeNodeType}
     * @memberof RestNode
     */
    'Type'?: TreeNodeType;
    /**
     * 
     * @type {Array<RestUserMeta>}
     * @memberof RestNode
     */
    'UserMetadata'?: Array<RestUserMeta>;
    /**
     * 
     * @type {string}
     * @memberof RestNode
     */
    'Uuid'?: string;
}


/**
 * 
 * @export
 * @interface RestNodeCollection
 */
export interface RestNodeCollection {
    /**
     * 
     * @type {Array<TreeSearchFacet>}
     * @memberof RestNodeCollection
     */
    'Facets'?: Array<TreeSearchFacet>;
    /**
     * 
     * @type {Array<RestNode>}
     * @memberof RestNodeCollection
     */
    'Nodes'?: Array<RestNode>;
    /**
     * 
     * @type {RestPagination}
     * @memberof RestNodeCollection
     */
    'Pagination'?: RestPagination;
}
/**
 * 
 * @export
 * @interface RestNodeLocator
 */
export interface RestNodeLocator {
    /**
     * 
     * @type {string}
     * @memberof RestNodeLocator
     */
    'Path'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestNodeLocator
     */
    'Uuid'?: string;
}
/**
 * 
 * @export
 * @interface RestNodeLocators
 */
export interface RestNodeLocators {
    /**
     * 
     * @type {Array<RestNodeLocator>}
     * @memberof RestNodeLocators
     */
    'Many'?: Array<RestNodeLocator>;
}
/**
 * 
 * @export
 * @interface RestNodeUpdates
 */
export interface RestNodeUpdates {
    /**
     * 
     * @type {RestMetaToggle}
     * @memberof RestNodeUpdates
     */
    'Bookmark'?: RestMetaToggle;
    /**
     * 
     * @type {RestMetaToggle}
     * @memberof RestNodeUpdates
     */
    'ContentLock'?: RestMetaToggle;
    /**
     * 
     * @type {Array<RestMetaUpdate>}
     * @memberof RestNodeUpdates
     */
    'MetaUpdates'?: Array<RestMetaUpdate>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RestNsOp = {
    Put: 'PUT',
    Delete: 'DELETE'
} as const;

export type RestNsOp = typeof RestNsOp[keyof typeof RestNsOp];


/**
 * 
 * @export
 * @interface RestPagination
 */
export interface RestPagination {
    /**
     * 
     * @type {number}
     * @memberof RestPagination
     */
    'CurrentOffset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RestPagination
     */
    'CurrentPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof RestPagination
     */
    'Limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RestPagination
     */
    'NextOffset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RestPagination
     */
    'PrevOffset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RestPagination
     */
    'Total'?: number;
    /**
     * 
     * @type {number}
     * @memberof RestPagination
     */
    'TotalPages'?: number;
}
/**
 * 
 * @export
 * @interface RestPerformActionResponse
 */
export interface RestPerformActionResponse {
    /**
     * 
     * @type {Array<RestNode>}
     * @memberof RestPerformActionResponse
     */
    'AffectedNodes'?: Array<RestNode>;
    /**
     * 
     * @type {RestActionStatus}
     * @memberof RestPerformActionResponse
     */
    'Status'?: RestActionStatus;
    /**
     * 
     * @type {Array<RestBackgroundAction>}
     * @memberof RestPerformActionResponse
     */
    'Tasks'?: Array<RestBackgroundAction>;
}


/**
 * 
 * @export
 * @interface RestPublicLinkDeleteSuccess
 */
export interface RestPublicLinkDeleteSuccess {
    /**
     * 
     * @type {string}
     * @memberof RestPublicLinkDeleteSuccess
     */
    'Message'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestPublicLinkDeleteSuccess
     */
    'Uuid'?: string;
}
/**
 * 
 * @export
 * @interface RestPublicLinkRequest
 */
export interface RestPublicLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof RestPublicLinkRequest
     */
    'CreatePassword'?: string;
    /**
     * 
     * @type {RestShareLink}
     * @memberof RestPublicLinkRequest
     */
    'Link'?: RestShareLink;
    /**
     * 
     * @type {boolean}
     * @memberof RestPublicLinkRequest
     */
    'PasswordEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestPublicLinkRequest
     */
    'UpdateCustomHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestPublicLinkRequest
     */
    'UpdatePassword'?: string;
}
/**
 * 
 * @export
 * @interface RestRevisionMeta
 */
export interface RestRevisionMeta {
    /**
     * 
     * @type {string}
     * @memberof RestRevisionMeta
     */
    'Description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestRevisionMeta
     */
    'Uuid'?: string;
}
/**
 * Request to create a selection from a list of nodes.
 * @export
 * @interface RestSelection
 */
export interface RestSelection {
    /**
     * 
     * @type {Array<RestNode>}
     * @memberof RestSelection
     */
    'Nodes'?: Array<RestNode>;
    /**
     * 
     * @type {string}
     * @memberof RestSelection
     */
    'Uuid'?: string;
}
/**
 * 
 * @export
 * @interface RestShareLink
 */
export interface RestShareLink {
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'AccessEnd'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'AccessStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'CurrentDownloads'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'Description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'Label'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'LinkHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'LinkUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'MaxDownloads'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RestShareLink
     */
    'PasswordRequired'?: boolean;
    /**
     * 
     * @type {Array<RestShareLinkAccessType>}
     * @memberof RestShareLink
     */
    'Permissions'?: Array<RestShareLinkAccessType>;
    /**
     * 
     * @type {Array<ServiceResourcePolicy>}
     * @memberof RestShareLink
     */
    'Policies'?: Array<ServiceResourcePolicy>;
    /**
     * 
     * @type {boolean}
     * @memberof RestShareLink
     */
    'PoliciesContextEditable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RestShareLink
     */
    'RestrictToTargetUsers'?: boolean;
    /**
     * 
     * @type {Array<TreeNode>}
     * @memberof RestShareLink
     */
    'RootNodes'?: Array<TreeNode>;
    /**
     * 
     * @type {{ [key: string]: RestShareLinkTargetUser; }}
     * @memberof RestShareLink
     */
    'TargetUsers'?: { [key: string]: RestShareLinkTargetUser; };
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'UserLogin'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'UserUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'Uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestShareLink
     */
    'ViewTemplateName'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RestShareLinkAccessType = {
    NoAccess: 'NoAccess',
    Preview: 'Preview',
    Download: 'Download',
    Upload: 'Upload'
} as const;

export type RestShareLinkAccessType = typeof RestShareLinkAccessType[keyof typeof RestShareLinkAccessType];


/**
 * 
 * @export
 * @interface RestShareLinkTargetUser
 */
export interface RestShareLinkTargetUser {
    /**
     * 
     * @type {string}
     * @memberof RestShareLinkTargetUser
     */
    'Display'?: string;
    /**
     * 
     * @type {number}
     * @memberof RestShareLinkTargetUser
     */
    'DownloadCount'?: number;
}
/**
 * 
 * @export
 * @interface RestTemplate
 */
export interface RestTemplate {
    /**
     * 
     * @type {boolean}
     * @memberof RestTemplate
     */
    'Editable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestTemplate
     */
    'Label'?: string;
    /**
     * 
     * @type {RestTemplateNode}
     * @memberof RestTemplate
     */
    'Node'?: RestTemplateNode;
    /**
     * 
     * @type {Array<ServiceResourcePolicy>}
     * @memberof RestTemplate
     */
    'Policies'?: Array<ServiceResourcePolicy>;
    /**
     * 
     * @type {string}
     * @memberof RestTemplate
     */
    'UUID'?: string;
}
/**
 * 
 * @export
 * @interface RestTemplateNode
 */
export interface RestTemplateNode {
    /**
     * 
     * @type {{ [key: string]: TreeNode; }}
     * @memberof RestTemplateNode
     */
    'Children'?: { [key: string]: TreeNode; };
    /**
     * 
     * @type {TreeNode}
     * @memberof RestTemplateNode
     */
    'Node'?: TreeNode;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RestUserActionType = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
} as const;

export type RestUserActionType = typeof RestUserActionType[keyof typeof RestUserActionType];


/**
 * 
 * @export
 * @interface RestUserMeta
 */
export interface RestUserMeta {
    /**
     * 
     * @type {boolean}
     * @memberof RestUserMeta
     */
    'Editable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RestUserMeta
     */
    'JsonValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestUserMeta
     */
    'Namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestUserMeta
     */
    'NodeUuid'?: string;
}
/**
 * 
 * @export
 * @interface RestUserMetaList
 */
export interface RestUserMetaList {
    /**
     * 
     * @type {Array<RestUserMeta>}
     * @memberof RestUserMetaList
     */
    'UserMeta'?: Array<RestUserMeta>;
}
/**
 * 
 * @export
 * @interface RestUserMetaNamespaceCollection
 */
export interface RestUserMetaNamespaceCollection {
    /**
     * 
     * @type {Array<IdmUserMetaNamespace>}
     * @memberof RestUserMetaNamespaceCollection
     */
    'Namespaces'?: Array<IdmUserMetaNamespace>;
}
/**
 * 
 * @export
 * @interface ServiceResourcePolicy
 */
export interface ServiceResourcePolicy {
    /**
     * 
     * @type {ServiceResourcePolicyAction}
     * @memberof ServiceResourcePolicy
     */
    'Action'?: ServiceResourcePolicyAction;
    /**
     * 
     * @type {ServiceResourcePolicyPolicyEffect}
     * @memberof ServiceResourcePolicy
     */
    'Effect'?: ServiceResourcePolicyPolicyEffect;
    /**
     * 
     * @type {string}
     * @memberof ServiceResourcePolicy
     */
    'JsonConditions'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceResourcePolicy
     */
    'Resource'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceResourcePolicy
     */
    'Subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceResourcePolicy
     */
    'id'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceResourcePolicyAction = {
    Any: 'ANY',
    Owner: 'OWNER',
    Read: 'READ',
    Write: 'WRITE',
    EditRules: 'EDIT_RULES'
} as const;

export type ServiceResourcePolicyAction = typeof ServiceResourcePolicyAction[keyof typeof ServiceResourcePolicyAction];


/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceResourcePolicyPolicyEffect = {
    Deny: 'deny',
    Allow: 'allow'
} as const;

export type ServiceResourcePolicyPolicyEffect = typeof ServiceResourcePolicyPolicyEffect[keyof typeof ServiceResourcePolicyPolicyEffect];


/**
 * 
 * @export
 * @interface ServiceResourcePolicyQuery
 */
export interface ServiceResourcePolicyQuery {
    /**
     * 
     * @type {ServiceResourcePolicyAction}
     * @memberof ServiceResourcePolicyQuery
     */
    'Action'?: ServiceResourcePolicyAction;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceResourcePolicyQuery
     */
    'Any'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceResourcePolicyQuery
     */
    'Empty'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceResourcePolicyQuery
     */
    'LeftIdentifier'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceResourcePolicyQuery
     */
    'Subjects'?: Array<string>;
}


/**
 * 
 * @export
 * @interface TreeChangeLog
 */
export interface TreeChangeLog {
    /**
     * 
     * @type {string}
     * @memberof TreeChangeLog
     */
    'Data'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeChangeLog
     */
    'Description'?: string;
    /**
     * 
     * @type {TreeNodeChangeEvent}
     * @memberof TreeChangeLog
     */
    'Event'?: TreeNodeChangeEvent;
    /**
     * 
     * @type {TreeNode}
     * @memberof TreeChangeLog
     */
    'Location'?: TreeNode;
    /**
     * 
     * @type {string}
     * @memberof TreeChangeLog
     */
    'MTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeChangeLog
     */
    'OwnerUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeChangeLog
     */
    'Size'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeChangeLog
     */
    'Uuid'?: string;
}
/**
 * 
 * @export
 * @interface TreeGeoPoint
 */
export interface TreeGeoPoint {
    /**
     * 
     * @type {number}
     * @memberof TreeGeoPoint
     */
    'Lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof TreeGeoPoint
     */
    'Lon'?: number;
}
/**
 * 
 * @export
 * @interface TreeGeoQuery
 */
export interface TreeGeoQuery {
    /**
     * 
     * @type {TreeGeoPoint}
     * @memberof TreeGeoQuery
     */
    'BottomRight'?: TreeGeoPoint;
    /**
     * 
     * @type {TreeGeoPoint}
     * @memberof TreeGeoQuery
     */
    'Center'?: TreeGeoPoint;
    /**
     * Example formats supported: \"5in\" \"5inch\" \"7yd\" \"7yards\" \"9ft\" \"9feet\" \"11km\" \"11kilometers\" \"3nm\" \"3nauticalmiles\" \"13mm\" \"13millimeters\" \"15cm\" \"15centimeters\" \"17mi\" \"17miles\" \"19m\" \"19meters\" If the unit cannot be determined, the entire string is parsed and the unit of meters is assumed.
     * @type {string}
     * @memberof TreeGeoQuery
     */
    'Distance'?: string;
    /**
     * 
     * @type {TreeGeoPoint}
     * @memberof TreeGeoQuery
     */
    'TopLeft'?: TreeGeoPoint;
}
/**
 * 
 * @export
 * @interface TreeNode
 */
export interface TreeNode {
    /**
     * 
     * @type {Array<TreeWorkspaceRelativePath>}
     * @memberof TreeNode
     */
    'AppearsIn'?: Array<TreeWorkspaceRelativePath>;
    /**
     * 
     * @type {Array<TreeChangeLog>}
     * @memberof TreeNode
     */
    'Commits'?: Array<TreeChangeLog>;
    /**
     * 
     * @type {string}
     * @memberof TreeNode
     */
    'Etag'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeNode
     */
    'MTime'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TreeNode
     */
    'MetaStore'?: { [key: string]: string; };
    /**
     * Permission mode, like 0777. Stored as string using custom ModeString field.
     * @type {number}
     * @memberof TreeNode
     */
    'Mode'?: number;
    /**
     * 
     * @type {string}
     * @memberof TreeNode
     */
    'ModeString'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeNode
     */
    'Path'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeNode
     */
    'Size'?: string;
    /**
     * 
     * @type {TreeNodeType}
     * @memberof TreeNode
     */
    'Type'?: TreeNodeType;
    /**
     * 
     * @type {string}
     * @memberof TreeNode
     */
    'Uuid'?: string;
}


/**
 * 
 * @export
 * @interface TreeNodeChangeEvent
 */
export interface TreeNodeChangeEvent {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TreeNodeChangeEvent
     */
    'Metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof TreeNodeChangeEvent
     */
    'Optimistic'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TreeNodeChangeEvent
     */
    'Silent'?: boolean;
    /**
     * 
     * @type {TreeNode}
     * @memberof TreeNodeChangeEvent
     */
    'Source'?: TreeNode;
    /**
     * 
     * @type {TreeNode}
     * @memberof TreeNodeChangeEvent
     */
    'Target'?: TreeNode;
    /**
     * 
     * @type {TreeNodeChangeEventEventType}
     * @memberof TreeNodeChangeEvent
     */
    'Type'?: TreeNodeChangeEventEventType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TreeNodeChangeEventEventType = {
    Create: 'CREATE',
    Read: 'READ',
    UpdatePath: 'UPDATE_PATH',
    UpdateContent: 'UPDATE_CONTENT',
    UpdateMeta: 'UPDATE_META',
    UpdateUserMeta: 'UPDATE_USER_META',
    Delete: 'DELETE'
} as const;

export type TreeNodeChangeEventEventType = typeof TreeNodeChangeEventEventType[keyof typeof TreeNodeChangeEventEventType];


/**
 * 
 * @export
 * @enum {string}
 */

export const TreeNodeType = {
    Unknown: 'UNKNOWN',
    Leaf: 'LEAF',
    Collection: 'COLLECTION'
} as const;

export type TreeNodeType = typeof TreeNodeType[keyof typeof TreeNodeType];


/**
 * 
 * @export
 * @interface TreeQuery
 */
export interface TreeQuery {
    /**
     * 
     * @type {string}
     * @memberof TreeQuery
     */
    'Content'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeQuery
     */
    'DurationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeQuery
     */
    'ETag'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeQuery
     */
    'Extension'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeQuery
     */
    'FileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeQuery
     */
    'FileNameOrContent'?: string;
    /**
     * Bleve-like search query to search for a specific metadata value. When querying nodes, this will redirect this query to the Search Engine. When filtering an input, this will load an in-memory bleve engine to evaluate the node.  Bleve query string format is a space separated list of `[+-]key:value`, where node meta keys must be prepended with \"Meta.\" For Example, for tags: `+Meta.usermeta-tags:myvalue`
     * @type {string}
     * @memberof TreeQuery
     */
    'FreeString'?: string;
    /**
     * 
     * @type {TreeGeoQuery}
     * @memberof TreeQuery
     */
    'GeoQuery'?: TreeGeoQuery;
    /**
     * 
     * @type {string}
     * @memberof TreeQuery
     */
    'MaxDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeQuery
     */
    'MaxSize'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeQuery
     */
    'MinDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeQuery
     */
    'MinSize'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TreeQuery
     */
    'Not'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TreeQuery
     */
    'PathDepth'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TreeQuery
     */
    'PathPrefix'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TreeQuery
     */
    'Paths'?: Array<string>;
    /**
     * 
     * @type {TreeNodeType}
     * @memberof TreeQuery
     */
    'Type'?: TreeNodeType;
    /**
     * 
     * @type {Array<string>}
     * @memberof TreeQuery
     */
    'UUIDs'?: Array<string>;
}


/**
 * 
 * @export
 * @interface TreeSearchFacet
 */
export interface TreeSearchFacet {
    /**
     * 
     * @type {number}
     * @memberof TreeSearchFacet
     */
    'Count'?: number;
    /**
     * 
     * @type {number}
     * @memberof TreeSearchFacet
     */
    'End'?: number;
    /**
     * 
     * @type {string}
     * @memberof TreeSearchFacet
     */
    'FieldName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeSearchFacet
     */
    'Label'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeSearchFacet
     */
    'Max'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeSearchFacet
     */
    'Min'?: string;
    /**
     * 
     * @type {number}
     * @memberof TreeSearchFacet
     */
    'Start'?: number;
    /**
     * 
     * @type {string}
     * @memberof TreeSearchFacet
     */
    'Term'?: string;
}
/**
 * 
 * @export
 * @interface TreeWorkspaceRelativePath
 */
export interface TreeWorkspaceRelativePath {
    /**
     * 
     * @type {string}
     * @memberof TreeWorkspaceRelativePath
     */
    'Path'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeWorkspaceRelativePath
     */
    'WsLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeWorkspaceRelativePath
     */
    'WsScope'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeWorkspaceRelativePath
     */
    'WsSlug'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeWorkspaceRelativePath
     */
    'WsUuid'?: string;
}

/**
 * NodeServiceApi - axios parameter creator
 * @export
 */
export const NodeServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve information about an action running in background
         * @param {BackgroundActionInfoNameEnum} name 
         * @param {string} jobUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundActionInfo: async (name: BackgroundActionInfoNameEnum, jobUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('backgroundActionInfo', 'name', name)
            // verify required parameter 'jobUuid' is not null or undefined
            assertParamExists('backgroundActionInfo', 'jobUuid', jobUuid)
            const localVarPath = `/n/action/{Name}/{JobUuid}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"JobUuid"}}`, encodeURIComponent(String(jobUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
         * @param {RestBatchUpdateMetaList} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUpdateMeta: async (body: RestBatchUpdateMetaList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('batchUpdateMeta', 'body', body)
            const localVarPath = `/n/meta/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send control commands to a background job
         * @param {ControlBackgroundActionNameEnum} name 
         * @param {string} jobUuid 
         * @param {JobsCtrlCommand} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlBackgroundAction: async (name: ControlBackgroundActionNameEnum, jobUuid: string, command: JobsCtrlCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('controlBackgroundAction', 'name', name)
            // verify required parameter 'jobUuid' is not null or undefined
            assertParamExists('controlBackgroundAction', 'jobUuid', jobUuid)
            // verify required parameter 'command' is not null or undefined
            assertParamExists('controlBackgroundAction', 'command', command)
            const localVarPath = `/n/action/{Name}/{JobUuid}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"JobUuid"}}`, encodeURIComponent(String(jobUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(command, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
         * @param {RestCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (body: RestCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('create', 'body', body)
            const localVarPath = `/n/nodes/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a public link on a given node
         * @param {string} uuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicLink: async (uuid: string, publicLinkRequest: RestPublicLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('createPublicLink', 'uuid', uuid)
            // verify required parameter 'publicLinkRequest' is not null or undefined
            assertParamExists('createPublicLink', 'publicLinkRequest', publicLinkRequest)
            const localVarPath = `/n/node/{Uuid}/link`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create and persist a temporary selection of nodes, that can be used by other actions
         * @param {RestSelection} body Request to create a selection from a list of nodes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSelection: async (body: RestSelection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createSelection', 'body', body)
            const localVarPath = `/n/selection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a public link
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicLink: async (linkUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkUuid' is not null or undefined
            assertParamExists('deletePublicLink', 'linkUuid', linkUuid)
            const localVarPath = `/n/link/{LinkUuid}`
                .replace(`{${"LinkUuid"}}`, encodeURIComponent(String(linkUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load a node by its Uuid
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUuid: async (uuid: string, path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getByUuid', 'uuid', uuid)
            const localVarPath = `/n/node/{Uuid}`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load public link information by Uuid
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicLink: async (linkUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkUuid' is not null or undefined
            assertParamExists('getPublicLink', 'linkUuid', linkUuid)
            const localVarPath = `/n/link/{LinkUuid}`
                .replace(`{${"LinkUuid"}}`, encodeURIComponent(String(linkUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {ListNamespaceValuesOperationOperationEnum} [operationOperation] 
         * @param {Array<string>} [operationValues] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaceValues: async (namespace: string, operationOperation?: ListNamespaceValuesOperationOperationEnum, operationValues?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listNamespaceValues', 'namespace', namespace)
            const localVarPath = `/n/meta/namespace/{Namespace}`
                .replace(`{${"Namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (operationOperation !== undefined) {
                localVarQueryParameter['Operation.Operation'] = operationOperation;
            }

            if (operationValues) {
                localVarQueryParameter['Operation.Values'] = operationValues;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List defined meta namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/n/meta/namespace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all known versions of a node
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions: async (uuid: string, path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('listVersions', 'uuid', uuid)
            const localVarPath = `/n/node/{Uuid}/versions`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generic request to either list (using Locators) or search (using Query) for nodes
         * @param {RestLookupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookup: async (body: RestLookupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('lookup', 'body', body)
            const localVarPath = `/n/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
         * @param {string} uuid 
         * @param {RestNodeUpdates} nodeUpdates 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchNode: async (uuid: string, nodeUpdates: RestNodeUpdates, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('patchNode', 'uuid', uuid)
            // verify required parameter 'nodeUpdates' is not null or undefined
            assertParamExists('patchNode', 'nodeUpdates', nodeUpdates)
            const localVarPath = `/n/node/{Uuid}`
                .replace(`{${"Uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeUpdates, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
         * @param {PerformActionNameEnum} name 
         * @param {RestActionParameters} parameters 
         * @param {string} [jobUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performAction: async (name: PerformActionNameEnum, parameters: RestActionParameters, jobUuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('performAction', 'name', name)
            // verify required parameter 'parameters' is not null or undefined
            assertParamExists('performAction', 'parameters', parameters)
            const localVarPath = `/n/action/{Name}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (jobUuid !== undefined) {
                localVarQueryParameter['JobUuid'] = jobUuid;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search a list of meta by node Id or by User id and by namespace
         * @param {IdmSearchUserMetaRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMeta: async (body: IdmSearchUserMetaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('searchMeta', 'body', body)
            const localVarPath = `/n/meta/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available templates for hydrating empty files
         * @param {string} [templateType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templates: async (templateType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/n/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (templateType !== undefined) {
                localVarQueryParameter['TemplateType'] = templateType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add/delete a values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {RestNamespaceValuesOperation} operation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceValues: async (namespace: string, operation: RestNamespaceValuesOperation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateNamespaceValues', 'namespace', namespace)
            // verify required parameter 'operation' is not null or undefined
            assertParamExists('updateNamespaceValues', 'operation', operation)
            const localVarPath = `/n/meta/namespace/{Namespace}`
                .replace(`{${"Namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update public link settings
         * @param {string} linkUuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicLink: async (linkUuid: string, publicLinkRequest: RestPublicLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkUuid' is not null or undefined
            assertParamExists('updatePublicLink', 'linkUuid', linkUuid)
            // verify required parameter 'publicLinkRequest' is not null or undefined
            assertParamExists('updatePublicLink', 'publicLinkRequest', publicLinkRequest)
            const localVarPath = `/n/link/{LinkUuid}`
                .replace(`{${"LinkUuid"}}`, encodeURIComponent(String(linkUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
         * @param {boolean} [all] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBookmarks: async (all?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/n/nodes/bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (all !== undefined) {
                localVarQueryParameter['All'] = all;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeServiceApi - functional programming interface
 * @export
 */
export const NodeServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodeServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve information about an action running in background
         * @param {BackgroundActionInfoNameEnum} name 
         * @param {string} jobUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backgroundActionInfo(name: BackgroundActionInfoNameEnum, jobUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestBackgroundAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backgroundActionInfo(name, jobUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.backgroundActionInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
         * @param {RestBatchUpdateMetaList} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchUpdateMeta(body: RestBatchUpdateMetaList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestBatchUpdateMetaList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchUpdateMeta(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.batchUpdateMeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send control commands to a background job
         * @param {ControlBackgroundActionNameEnum} name 
         * @param {string} jobUuid 
         * @param {JobsCtrlCommand} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async controlBackgroundAction(name: ControlBackgroundActionNameEnum, jobUuid: string, command: JobsCtrlCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestBackgroundAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.controlBackgroundAction(name, jobUuid, command, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.controlBackgroundAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
         * @param {RestCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(body: RestCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNodeCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a public link on a given node
         * @param {string} uuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicLink(uuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestShareLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicLink(uuid, publicLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.createPublicLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create and persist a temporary selection of nodes, that can be used by other actions
         * @param {RestSelection} body Request to create a selection from a list of nodes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSelection(body: RestSelection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestSelection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSelection(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.createSelection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a public link
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicLink(linkUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestPublicLinkDeleteSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicLink(linkUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.deletePublicLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Load a node by its Uuid
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUuid(uuid: string, path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUuid(uuid, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.getByUuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Load public link information by Uuid
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicLink(linkUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestShareLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicLink(linkUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.getPublicLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {ListNamespaceValuesOperationOperationEnum} [operationOperation] 
         * @param {Array<string>} [operationValues] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNamespaceValues(namespace: string, operationOperation?: ListNamespaceValuesOperationOperationEnum, operationValues?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNamespaceValuesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNamespaceValues(namespace, operationOperation, operationValues, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.listNamespaceValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List defined meta namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNamespaces(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestUserMetaNamespaceCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNamespaces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.listNamespaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all known versions of a node
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVersions(uuid: string, path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNodeCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVersions(uuid, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.listVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generic request to either list (using Locators) or search (using Query) for nodes
         * @param {RestLookupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookup(body: RestLookupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNodeCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookup(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.lookup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
         * @param {string} uuid 
         * @param {RestNodeUpdates} nodeUpdates 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchNode(uuid: string, nodeUpdates: RestNodeUpdates, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchNode(uuid, nodeUpdates, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.patchNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
         * @param {PerformActionNameEnum} name 
         * @param {RestActionParameters} parameters 
         * @param {string} [jobUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async performAction(name: PerformActionNameEnum, parameters: RestActionParameters, jobUuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestPerformActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.performAction(name, parameters, jobUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.performAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search a list of meta by node Id or by User id and by namespace
         * @param {IdmSearchUserMetaRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMeta(body: IdmSearchUserMetaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestUserMetaList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMeta(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.searchMeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List available templates for hydrating empty files
         * @param {string} [templateType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templates(templateType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestListTemplatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templates(templateType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.templates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add/delete a values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {RestNamespaceValuesOperation} operation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamespaceValues(namespace: string, operation: RestNamespaceValuesOperation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNamespaceValuesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNamespaceValues(namespace, operation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.updateNamespaceValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update public link settings
         * @param {string} linkUuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicLink(linkUuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestShareLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicLink(linkUuid, publicLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.updatePublicLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
         * @param {boolean} [all] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBookmarks(all?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestNodeCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBookmarks(all, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeServiceApi.userBookmarks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NodeServiceApi - factory interface
 * @export
 */
export const NodeServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodeServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve information about an action running in background
         * @param {BackgroundActionInfoNameEnum} name 
         * @param {string} jobUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundActionInfo(name: BackgroundActionInfoNameEnum, jobUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RestBackgroundAction> {
            return localVarFp.backgroundActionInfo(name, jobUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
         * @param {RestBatchUpdateMetaList} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUpdateMeta(body: RestBatchUpdateMetaList, options?: RawAxiosRequestConfig): AxiosPromise<RestBatchUpdateMetaList> {
            return localVarFp.batchUpdateMeta(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send control commands to a background job
         * @param {ControlBackgroundActionNameEnum} name 
         * @param {string} jobUuid 
         * @param {JobsCtrlCommand} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlBackgroundAction(name: ControlBackgroundActionNameEnum, jobUuid: string, command: JobsCtrlCommand, options?: RawAxiosRequestConfig): AxiosPromise<RestBackgroundAction> {
            return localVarFp.controlBackgroundAction(name, jobUuid, command, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
         * @param {RestCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(body: RestCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection> {
            return localVarFp.create(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a public link on a given node
         * @param {string} uuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicLink(uuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestShareLink> {
            return localVarFp.createPublicLink(uuid, publicLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create and persist a temporary selection of nodes, that can be used by other actions
         * @param {RestSelection} body Request to create a selection from a list of nodes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSelection(body: RestSelection, options?: RawAxiosRequestConfig): AxiosPromise<RestSelection> {
            return localVarFp.createSelection(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a public link
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicLink(linkUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RestPublicLinkDeleteSuccess> {
            return localVarFp.deletePublicLink(linkUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load a node by its Uuid
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUuid(uuid: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestNode> {
            return localVarFp.getByUuid(uuid, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load public link information by Uuid
         * @param {string} linkUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicLink(linkUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RestShareLink> {
            return localVarFp.getPublicLink(linkUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {ListNamespaceValuesOperationOperationEnum} [operationOperation] 
         * @param {Array<string>} [operationValues] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaceValues(namespace: string, operationOperation?: ListNamespaceValuesOperationOperationEnum, operationValues?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<RestNamespaceValuesResponse> {
            return localVarFp.listNamespaceValues(namespace, operationOperation, operationValues, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List defined meta namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces(options?: RawAxiosRequestConfig): AxiosPromise<RestUserMetaNamespaceCollection> {
            return localVarFp.listNamespaces(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all known versions of a node
         * @param {string} uuid 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions(uuid: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection> {
            return localVarFp.listVersions(uuid, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generic request to either list (using Locators) or search (using Query) for nodes
         * @param {RestLookupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookup(body: RestLookupRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection> {
            return localVarFp.lookup(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
         * @param {string} uuid 
         * @param {RestNodeUpdates} nodeUpdates 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchNode(uuid: string, nodeUpdates: RestNodeUpdates, options?: RawAxiosRequestConfig): AxiosPromise<RestNode> {
            return localVarFp.patchNode(uuid, nodeUpdates, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
         * @param {PerformActionNameEnum} name 
         * @param {RestActionParameters} parameters 
         * @param {string} [jobUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performAction(name: PerformActionNameEnum, parameters: RestActionParameters, jobUuid?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestPerformActionResponse> {
            return localVarFp.performAction(name, parameters, jobUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search a list of meta by node Id or by User id and by namespace
         * @param {IdmSearchUserMetaRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMeta(body: IdmSearchUserMetaRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestUserMetaList> {
            return localVarFp.searchMeta(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List available templates for hydrating empty files
         * @param {string} [templateType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templates(templateType?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestListTemplatesResponse> {
            return localVarFp.templates(templateType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add/delete a values for a given namespace
         * @param {string} namespace List persisted values for this namespace
         * @param {RestNamespaceValuesOperation} operation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceValues(namespace: string, operation: RestNamespaceValuesOperation, options?: RawAxiosRequestConfig): AxiosPromise<RestNamespaceValuesResponse> {
            return localVarFp.updateNamespaceValues(namespace, operation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update public link settings
         * @param {string} linkUuid 
         * @param {RestPublicLinkRequest} publicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicLink(linkUuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestShareLink> {
            return localVarFp.updatePublicLink(linkUuid, publicLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
         * @param {boolean} [all] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBookmarks(all?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<RestNodeCollection> {
            return localVarFp.userBookmarks(all, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodeServiceApi - object-oriented interface
 * @export
 * @class NodeServiceApi
 * @extends {BaseAPI}
 */
export class NodeServiceApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve information about an action running in background
     * @param {BackgroundActionInfoNameEnum} name 
     * @param {string} jobUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public backgroundActionInfo(name: BackgroundActionInfoNameEnum, jobUuid: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).backgroundActionInfo(name, jobUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
     * @param {RestBatchUpdateMetaList} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public batchUpdateMeta(body: RestBatchUpdateMetaList, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).batchUpdateMeta(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send control commands to a background job
     * @param {ControlBackgroundActionNameEnum} name 
     * @param {string} jobUuid 
     * @param {JobsCtrlCommand} command 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public controlBackgroundAction(name: ControlBackgroundActionNameEnum, jobUuid: string, command: JobsCtrlCommand, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).controlBackgroundAction(name, jobUuid, command, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create one or many files (empty or hydrated from a TemplateUuid) or folders
     * @param {RestCreateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public create(body: RestCreateRequest, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).create(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a public link on a given node
     * @param {string} uuid 
     * @param {RestPublicLinkRequest} publicLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public createPublicLink(uuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).createPublicLink(uuid, publicLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create and persist a temporary selection of nodes, that can be used by other actions
     * @param {RestSelection} body Request to create a selection from a list of nodes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public createSelection(body: RestSelection, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).createSelection(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a public link
     * @param {string} linkUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public deletePublicLink(linkUuid: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).deletePublicLink(linkUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load a node by its Uuid
     * @param {string} uuid 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public getByUuid(uuid: string, path?: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).getByUuid(uuid, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load public link information by Uuid
     * @param {string} linkUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public getPublicLink(linkUuid: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).getPublicLink(linkUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List values for a given namespace
     * @param {string} namespace List persisted values for this namespace
     * @param {ListNamespaceValuesOperationOperationEnum} [operationOperation] 
     * @param {Array<string>} [operationValues] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public listNamespaceValues(namespace: string, operationOperation?: ListNamespaceValuesOperationOperationEnum, operationValues?: Array<string>, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).listNamespaceValues(namespace, operationOperation, operationValues, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List defined meta namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public listNamespaces(options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).listNamespaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all known versions of a node
     * @param {string} uuid 
     * @param {string} [path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public listVersions(uuid: string, path?: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).listVersions(uuid, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generic request to either list (using Locators) or search (using Query) for nodes
     * @param {RestLookupRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public lookup(body: RestLookupRequest, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).lookup(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
     * @param {string} uuid 
     * @param {RestNodeUpdates} nodeUpdates 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public patchNode(uuid: string, nodeUpdates: RestNodeUpdates, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).patchNode(uuid, nodeUpdates, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger an action on the tree. Returns a JobInfo describing a background task.
     * @param {PerformActionNameEnum} name 
     * @param {RestActionParameters} parameters 
     * @param {string} [jobUuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public performAction(name: PerformActionNameEnum, parameters: RestActionParameters, jobUuid?: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).performAction(name, parameters, jobUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search a list of meta by node Id or by User id and by namespace
     * @param {IdmSearchUserMetaRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public searchMeta(body: IdmSearchUserMetaRequest, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).searchMeta(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List available templates for hydrating empty files
     * @param {string} [templateType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public templates(templateType?: string, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).templates(templateType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add/delete a values for a given namespace
     * @param {string} namespace List persisted values for this namespace
     * @param {RestNamespaceValuesOperation} operation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public updateNamespaceValues(namespace: string, operation: RestNamespaceValuesOperation, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).updateNamespaceValues(namespace, operation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update public link settings
     * @param {string} linkUuid 
     * @param {RestPublicLinkRequest} publicLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public updatePublicLink(linkUuid: string, publicLinkRequest: RestPublicLinkRequest, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).updatePublicLink(linkUuid, publicLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
     * @param {boolean} [all] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeServiceApi
     */
    public userBookmarks(all?: boolean, options?: RawAxiosRequestConfig) {
        return NodeServiceApiFp(this.configuration).userBookmarks(all, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BackgroundActionInfoNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
} as const;
export type BackgroundActionInfoNameEnum = typeof BackgroundActionInfoNameEnum[keyof typeof BackgroundActionInfoNameEnum];
/**
 * @export
 */
export const ControlBackgroundActionNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
} as const;
export type ControlBackgroundActionNameEnum = typeof ControlBackgroundActionNameEnum[keyof typeof ControlBackgroundActionNameEnum];
/**
 * @export
 */
export const ListNamespaceValuesOperationOperationEnum = {
    Put: 'PUT',
    Delete: 'DELETE'
} as const;
export type ListNamespaceValuesOperationOperationEnum = typeof ListNamespaceValuesOperationOperationEnum[keyof typeof ListNamespaceValuesOperationOperationEnum];
/**
 * @export
 */
export const PerformActionNameEnum = {
    Delete: 'delete',
    Restore: 'restore',
    Copy: 'copy',
    Move: 'move',
    Extract: 'extract',
    Compress: 'compress'
} as const;
export type PerformActionNameEnum = typeof PerformActionNameEnum[keyof typeof PerformActionNameEnum];


